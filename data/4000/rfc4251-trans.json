{
  "title": {
    "text": "RFC 4251 - The Secure Shell (SSH) Protocol Architecture",
    "ja": "RFC 4251 - セキュアシェル（SSH）プロトコルアーキテクチャ"
  },
  "number": 4251,
  "created_at": "2020-08-15 12:55:21.967889+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                          T. Ylonen\nRequest for Comments: 4251              SSH Communications Security Corp\nCategory: Standards Track                                C. Lonvick, Ed.\n                                                     Cisco Systems, Inc.\n                                                            January 2006",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "The Secure Shell (SSH) Protocol Architecture",
      "ja": "セキュアシェル（SSH）プロトコルアーキテクチャ"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の状態"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "Copyright（C）The Internet Society（2006）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "The Secure Shell (SSH) Protocol is a protocol for secure remote login and other secure network services over an insecure network. This document describes the architecture of the SSH protocol, as well as the notation and terminology used in SSH protocol documents. It also discusses the SSH algorithm naming system that allows local extensions. The SSH protocol consists of three major components: The Transport Layer Protocol provides server authentication, confidentiality, and integrity with perfect forward secrecy. The User Authentication Protocol authenticates the client to the server. The Connection Protocol multiplexes the encrypted tunnel into several logical channels. Details of these protocols are described in separate documents.",
      "ja": "セキュアシェル（SSH）プロトコルは、安全でないリモートログインや、安全でないネットワークを介したその他の安全なネットワークサービスのためのプロトコルです。このドキュメントでは、SSHプロトコルのアーキテクチャと、SSHプロトコルドキュメントで使用されている表記法および用語について説明します。また、ローカル拡張を可能にするSSHアルゴリズムの命名システムについても説明します。 SSHプロトコルは、次の3つの主要コンポーネントで構成されています。トランスポート層プロトコルは、サーバー認証、機密性、および完全性転送完全性を備えた整合性を提供します。ユーザー認証プロトコルは、サーバーに対してクライアントを認証します。接続プロトコルは、暗号化されたトンネルをいくつかの論理チャネルに多重化します。これらのプロトコルの詳細は、別のドキュメントで説明されています。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n2. Contributors ....................................................3\n3. Conventions Used in This Document ...............................4\n4. Architecture ....................................................4\n   4.1. Host Keys ..................................................4\n   4.2. Extensibility ..............................................6\n   4.3. Policy Issues ..............................................6\n   4.4. Security Properties ........................................7\n   4.5. Localization and Character Set Support .....................7\n5. Data Type Representations Used in the SSH Protocols .............8\n6. Algorithm and Method Naming ....................................10\n7. Message Numbers ................................................11\n8. IANA Considerations ............................................12\n9. Security Considerations ........................................13\n   9.1. Pseudo-Random Number Generation ...........................13\n   9.2. Control Character Filtering ...............................14\n   9.3. Transport .................................................14\n        9.3.1. Confidentiality ....................................14\n        9.3.2. Data Integrity .....................................16\n        9.3.3. Replay .............................................16\n        9.3.4. Man-in-the-middle ..................................17\n        9.3.5. Denial of Service ..................................19\n        9.3.6. Covert Channels ....................................20\n        9.3.7. Forward Secrecy ....................................20\n        9.3.8. Ordering of Key Exchange Methods ...................20\n        9.3.9. Traffic Analysis ...................................21\n   9.4. Authentication Protocol ...................................21\n        9.4.1. Weak Transport .....................................21\n        9.4.2. Debug Messages .....................................22\n        9.4.3. Local Security Policy ..............................22\n        9.4.4. Public Key Authentication ..........................23\n        9.4.5. Password Authentication ............................23\n        9.4.6. Host-Based Authentication ..........................23\n   9.5. Connection Protocol .......................................24\n        9.5.1. End Point Security .................................24\n        9.5.2. Proxy Forwarding ...................................24\n        9.5.3. X11 Forwarding .....................................24\n10. References ....................................................26\n   10.1. Normative References .....................................26\n   10.2. Informative References ...................................26\nAuthors' Addresses ................................................29\nTrademark Notice ..................................................29",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Secure Shell (SSH) is a protocol for secure remote login and other secure network services over an insecure network. It consists of three major components:",
      "ja": "セキュアシェル（SSH）は、安全でないリモートログインや、安全でないネットワークを介したその他の安全なネットワークサービスのためのプロトコルです。 3つの主要コンポーネントで構成されています。"
    },
    {
      "indent": 3,
      "text": "o The Transport Layer Protocol [SSH-TRANS] provides server authentication, confidentiality, and integrity. It may optionally also provide compression. The transport layer will typically be run over a TCP/IP connection, but might also be used on top of any other reliable data stream.",
      "ja": "o トランスポート層プロトコル[SSH-TRANS]は、サーバー認証、機密性、および整合性を提供します。オプションで圧縮を提供することもできます。トランスポート層は通常、TCP / IP接続を介して実行されますが、他の信頼できるデータストリームの上で使用することもできます。"
    },
    {
      "indent": 3,
      "text": "o The User Authentication Protocol [SSH-USERAUTH] authenticates the client-side user to the server. It runs over the transport layer protocol.",
      "ja": "o ユーザー認証プロトコル[SSH-USERAUTH]は、サーバーに対してクライアント側ユーザーを認証します。トランスポート層プロトコル上で実行されます。"
    },
    {
      "indent": 3,
      "text": "o The Connection Protocol [SSH-CONNECT] multiplexes the encrypted tunnel into several logical channels. It runs over the user authentication protocol.",
      "ja": "o 接続プロトコル[SSH-CONNECT]は、暗号化されたトンネルをいくつかの論理チャネルに多重化します。ユーザー認証プロトコル上で実行されます。"
    },
    {
      "indent": 3,
      "text": "The client sends a service request once a secure transport layer connection has been established. A second service request is sent after user authentication is complete. This allows new protocols to be defined and coexist with the protocols listed above.",
      "ja": "安全なトランスポート層接続が確立されると、クライアントはサービス要求を送信します。ユーザー認証が完了すると、2番目のサービス要求が送信されます。これにより、新しいプロトコルを定義し、上記のプロトコルと共存させることができます。"
    },
    {
      "indent": 3,
      "text": "The connection protocol provides channels that can be used for a wide range of purposes. Standard methods are provided for setting up secure interactive shell sessions and for forwarding (\"tunneling\") arbitrary TCP/IP ports and X11 connections.",
      "ja": "接続プロトコルは、幅広い目的に使用できるチャネルを提供します。安全な対話型シェルセッションを設定し、任意のTCP / IPポートとX11接続を転送（「トンネリング」）するための標準的な方法が提供されています。"
    },
    {
      "indent": 0,
      "text": "2. Contributors",
      "section_title": true,
      "ja": "2. 貢献者"
    },
    {
      "indent": 3,
      "text": "The major original contributors of this set of documents have been: Tatu Ylonen, Tero Kivinen, Timo J. Rinne, Sami Lehtinen (all of SSH Communications Security Corp), and Markku-Juhani O. Saarinen (University of Jyvaskyla). Darren Moffat was the original editor of this set of documents and also made very substantial contributions.",
      "ja": "このドキュメントセットの主要な元の貢献者は、Tatu Ylonen、Tero Kivinen、Timo J. Rinne、Sami Lehtinen（SSH Communications Security Corpのすべて）、およびMarkku-Juhani O. Saarinen（Jyvaskyla大学）です。ダレンモファットは、この一連のドキュメントの最初の編集者であり、非常に大きな貢献もしました。"
    },
    {
      "indent": 3,
      "text": "Many people contributed to the development of this document over the years. People who should be acknowledged include Mats Andersson, Ben Harris, Bill Sommerfeld, Brent McClure, Niels Moller, Damien Miller, Derek Fawcus, Frank Cusack, Heikki Nousiainen, Jakob Schlyter, Jeff Van Dyke, Jeffrey Altman, Jeffrey Hutzelman, Jon Bright, Joseph Galbraith, Ken Hornstein, Markus Friedl, Martin Forssen, Nicolas Williams, Niels Provos, Perry Metzger, Peter Gutmann, Simon Josefsson, Simon Tatham, Wei Dai, Denis Bider, der Mouse, and Tadayoshi Kohno. Listing their names here does not mean that they endorse this document, but that they have contributed to it.",
      "ja": "このドキュメントの開発には、長年にわたって多くの人々が貢献してくれました。認められるべき人には、マット・アンダーソン、ベン・ハリス、ビル・ソマーフェルト、ブレント・マクルーア、ニールス・モラー、ダミアン・ミラー、デレク・フォーカス、フランク・カザック、ヘイッキ・ノイシャイネン、ジェイコブ・シュリター、ジェフ・ヴァン・ダイク、ジェフリー・アルトマン、ジェフリー・ハッツェルマン、ジョン・ブライト、ジョセフガルブレイス、ケンホーンスタイン、マーカスフリードル、マーティンフォーセン、ニコラスウィリアムズ、ニールスプロボス、ペリーメッツガー、ピーターグトマン、サイモンジョセフソン、サイモンタサム、ウェイダイ、デニスビダー、マウス、デアマウス、河野忠義。ここに彼らの名前をリストすることは、彼らがこの文書を支持することを意味するのではなく、彼らがそれに貢献したことを意味します。"
    },
    {
      "indent": 0,
      "text": "3. Conventions Used in This Document",
      "section_title": true,
      "ja": "3. このドキュメントで使用される規則"
    },
    {
      "indent": 3,
      "text": "All documents related to the SSH protocols shall use the keywords \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" to describe requirements. These keywords are to be interpreted as described in [RFC2119].",
      "ja": "SSHプロトコルに関連するすべてのドキュメントは、キーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」を使用するものとします。要件を説明する「オプション」。これらのキーワードは、[RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "The keywords \"PRIVATE USE\", \"HIERARCHICAL ALLOCATION\", \"FIRST COME FIRST SERVED\", \"EXPERT REVIEW\", \"SPECIFICATION REQUIRED\", \"IESG APPROVAL\", \"IETF CONSENSUS\", and \"STANDARDS ACTION\" that appear in this document when used to describe namespace allocation are to be interpreted as described in [RFC2434].",
      "ja": "このドキュメントに表示されるキーワード「プライベート使用」、「階層割り当て」、「ファーストカムファーストサーブド」、「エキスパートレビュー」、「仕様が必要」、「IESG承認」、「IETFコンセンサス」、および「標準アクション」名前空間の割り当てを説明するために使用されるものは、[RFC2434]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "Protocol fields and possible values to fill them are defined in this set of documents. Protocol fields will be defined in the message definitions. As an example, SSH_MSG_CHANNEL_DATA is defined as follows.",
      "ja": "プロトコルフィールドと、フィールドに入力できる値は、この一連のドキュメントで定義されています。プロトコルフィールドはメッセージ定義で定義されます。例として、SSH_MSG_CHANNEL_DATAは次のように定義されます。"
    },
    {
      "indent": 6,
      "text": "byte SSH_MSG_CHANNEL_DATA uint32 recipient channel string data",
      "ja": "バイトSSH_MSG_CHANNEL_DATA uint32受信者チャネル文字列データ"
    },
    {
      "indent": 3,
      "text": "Throughout these documents, when the fields are referenced, they will appear within single quotes. When values to fill those fields are referenced, they will appear within double quotes. Using the above example, possible values for 'data' are \"foo\" and \"bar\".",
      "ja": "これらのドキュメント全体で、フィールドが参照されている場合、フィールドは一重引用符で囲まれています。それらのフィールドを満たす値が参照される場合、それらは二重引用符で囲まれて表示されます。上記の例を使用すると、「data」の可能な値は「foo」と「bar」です。"
    },
    {
      "indent": 0,
      "text": "4. Architecture",
      "section_title": true,
      "ja": "4. 建築"
    },
    {
      "indent": 0,
      "text": "4.1. Host Keys",
      "section_title": true,
      "ja": "4.1. ホストキー"
    },
    {
      "indent": 3,
      "text": "Each server host SHOULD have a host key. Hosts MAY have multiple host keys using multiple different algorithms. Multiple hosts MAY share the same host key. If a host has keys at all, it MUST have at least one key that uses each REQUIRED public key algorithm (DSS [FIPS-186-2]).",
      "ja": "各サーバーホストにはホストキーが必要です（SHOULD）。ホストは、複数の異なるアルゴリズムを使用して複数のホストキーを持っている場合があります。複数のホストが同じホストキーを共有する場合があります。ホストに鍵がある場合、ホストには、それぞれの必須の公開鍵アルゴリズム（DSS [FIPS-186-2]）を使用する少なくとも1つの鍵が必要です。"
    },
    {
      "indent": 3,
      "text": "The server host key is used during key exchange to verify that the client is really talking to the correct server. For this to be possible, the client must have a priori knowledge of the server's public host key.",
      "ja": "サーバーホストキーは、クライアントが実際に正しいサーバーと通信していることを確認するために、キー交換中に使用されます。これを可能にするには、クライアントはサーバーの公開ホストキーについて事前に知っている必要があります。"
    },
    {
      "indent": 3,
      "text": "Two different trust models can be used:",
      "ja": "2つの異なる信頼モデルを使用できます。"
    },
    {
      "indent": 3,
      "text": "o The client has a local database that associates each host name (as typed by the user) with the corresponding public host key. This method requires no centrally administered infrastructure, and no third-party coordination. The downside is that the database of name-to-key associations may become burdensome to maintain.",
      "ja": "o クライアントには、各ホスト名（ユーザーが入力したもの）を対応する公開ホストキーに関連付けるローカルデータベースがあります。この方法では、集中管理されたインフラストラクチャやサードパーティの調整は必要ありません。欠点は、名前とキーの関連付けのデータベースを維持するのが面倒になることです。"
    },
    {
      "indent": 3,
      "text": "o The host name-to-key association is certified by a trusted certification authority (CA). The client only knows the CA root key, and can verify the validity of all host keys certified by accepted CAs.",
      "ja": "o ホスト名とキーの関連付けは、信頼された証明機関（CA）によって証明されています。クライアントはCAルートキーだけを知っており、承認されたCAによって認証されたすべてのホストキーの有効性を確認できます。"
    },
    {
      "indent": 3,
      "text": "The second alternative eases the maintenance problem, since ideally only a single CA key needs to be securely stored on the client. On the other hand, each host key must be appropriately certified by a central authority before authorization is possible. Also, a lot of trust is placed on the central infrastructure.",
      "ja": "2つ目の方法では、クライアントに安全に格納する必要があるのは1つのCAキーだけなので、メンテナンスの問題が軽減されます。一方、各ホストキーは、認証が可能になる前に中央機関によって適切に認証される必要があります。また、中央のインフラストラクチャには多くの信頼が置かれています。"
    },
    {
      "indent": 3,
      "text": "The protocol provides the option that the server name - host key association is not checked when connecting to the host for the first time. This allows communication without prior communication of host keys or certification. The connection still provides protection against passive listening; however, it becomes vulnerable to active man-in-the-middle attacks. Implementations SHOULD NOT normally allow such connections by default, as they pose a potential security problem. However, as there is no widely deployed key infrastructure available on the Internet at the time of this writing, this option makes the protocol much more usable during the transition time until such an infrastructure emerges, while still providing a much higher level of security than that offered by older solutions (e.g., telnet [RFC0854] and rlogin [RFC1282]).",
      "ja": "このプロトコルは、初めてホストに接続するときにサーバー名とホストキーの関連付けをチェックしないというオプションを提供します。これにより、事前のホストキーや認証の伝達なしに通信できます。接続は、パッシブリスニングに対する保護を提供します。ただし、アクティブな中間者攻撃に対して脆弱になります。実装は、潜在的なセキュリティ問題を引き起こすので、通常、デフォルトでそのような接続を許可しないでください。ただし、この記事の執筆時点ではインターネット上に広く展開されている主要なインフラストラクチャは存在しないため、このオプションを選択すると、移行期間中、このようなインフラストラクチャが出現するまでの間、プロトコルがより使いやすくなり、それよりもはるかに高いレベルのセキュリティが提供されます古いソリューション（telnet [RFC0854]やrlogin [RFC1282]など）によって提供されます。"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD try to make the best effort to check host keys. An example of a possible strategy is to only accept a host key without checking the first time a host is connected, save the key in a local database, and compare against that key on all future connections to that host.",
      "ja": "実装は、ホストキーをチェックするために最善の努力をする必要があります。可能な戦略の例としては、ホストが初めて接続されたときにチェックせずにホストキーのみを受け入れ、ローカルデータベースにキーを保存し、そのホストへの今後のすべての接続でそのキーと比較することです。"
    },
    {
      "indent": 3,
      "text": "Implementations MAY provide additional methods for verifying the correctness of host keys, e.g., a hexadecimal fingerprint derived from the SHA-1 hash [FIPS-180-2] of the public key. Such fingerprints can easily be verified by using telephone or other external communication channels.",
      "ja": "実装は、ホスト鍵の正当性を検証するための追加の方法、たとえば、公開鍵のSHA-1ハッシュ[FIPS-180-2]から派生した16進数のフィンガープリントを提供する場合があります。このような指紋は、電話またはその他の外部通信チャネルを使用して簡単に確認できます。"
    },
    {
      "indent": 3,
      "text": "All implementations SHOULD provide an option not to accept host keys that cannot be verified.",
      "ja": "すべての実装は、検証できないホストキーを受け入れないオプションを提供する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "The members of this Working Group believe that 'ease of use' is critical to end-user acceptance of security solutions, and no improvement in security is gained if the new solutions are not used. Thus, providing the option not to check the server host key is believed to improve the overall security of the Internet, even though it reduces the security of the protocol in configurations where it is allowed.",
      "ja": "このワーキンググループのメンバーは、エンドユーザーがセキュリティソリューションを受け入れるためには「使いやすさ」が重要であり、新しいソリューションを使用しないとセキュリティの向上は得られないと考えています。したがって、サーバーのホストキーをチェックしないオプションを提供すると、許可されている構成ではプロトコルのセキュリティが低下しますが、インターネットの全体的なセキュリティが向上すると考えられます。"
    },
    {
      "indent": 0,
      "text": "4.2. Extensibility",
      "section_title": true,
      "ja": "4.2. 拡張性"
    },
    {
      "indent": 3,
      "text": "We believe that the protocol will evolve over time, and some organizations will want to use their own encryption, authentication, and/or key exchange methods. Central registration of all extensions is cumbersome, especially for experimental or classified features. On the other hand, having no central registration leads to conflicts in method identifiers, making interoperability difficult.",
      "ja": "プロトコルは時間とともに進化し、一部の組織では独自の暗号化、認証、および/または鍵交換方法を使用したいと考えています。すべての拡張機能の集中登録は、特に実験的機能または分類された機能の場合、面倒です。一方、中央登録がないと、メソッド識別子の競合が発生し、相互運用性が難しくなります。"
    },
    {
      "indent": 3,
      "text": "We have chosen to identify algorithms, methods, formats, and extension protocols with textual names that are of a specific format. DNS names are used to create local namespaces where experimental or classified extensions can be defined without fear of conflicts with other implementations.",
      "ja": "特定の形式のテキスト名を使用して、アルゴリズム、メソッド、形式、および拡張プロトコルを識別することを選択しました。 DNS名は、他の実装との競合を恐れずに実験的または分類された拡張を定義できるローカル名前空間を作成するために使用されます。"
    },
    {
      "indent": 3,
      "text": "One design goal has been to keep the base protocol as simple as possible, and to require as few algorithms as possible. However, all implementations MUST support a minimal set of algorithms to ensure interoperability (this does not imply that the local policy on all hosts would necessarily allow these algorithms). The mandatory algorithms are specified in the relevant protocol documents.",
      "ja": "設計目標の1つは、基本プロトコルをできるだけシンプルに保ち、必要なアルゴリズムをできるだけ少なくすることです。ただし、すべての実装は相互運用性を保証するために最小限のアルゴリズムのセットをサポートする必要があります（これは、すべてのホストのローカルポリシーがこれらのアルゴリズムを必ずしも許可することを意味しません）。必須アルゴリズムは、関連するプロトコルドキュメントで指定されています。"
    },
    {
      "indent": 3,
      "text": "Additional algorithms, methods, formats, and extension protocols can be defined in separate documents. See Section 6, Algorithm Naming, for more information.",
      "ja": "追加のアルゴリズム、メソッド、フォーマット、および拡張プロトコルは、個別のドキュメントで定義できます。詳細については、セクション6「アルゴリズムの命名」を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.3. Policy Issues",
      "section_title": true,
      "ja": "4.3. ポリシーの問題"
    },
    {
      "indent": 3,
      "text": "The protocol allows full negotiation of encryption, integrity, key exchange, compression, and public key algorithms and formats. Encryption, integrity, public key, and compression algorithms can be different for each direction.",
      "ja": "このプロトコルにより、暗号化、整合性、鍵交換、圧縮、公開鍵のアルゴリズムと形式の完全なネゴシエーションが可能になります。暗号化、整合性、公開鍵、および圧縮アルゴリズムは、方向ごとに異なる場合があります。"
    },
    {
      "indent": 3,
      "text": "The following policy issues SHOULD be addressed in the configuration mechanisms of each implementation:",
      "ja": "次のポリシーの問題は、各実装の構成メカニズムで対処する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "o Encryption, integrity, and compression algorithms, separately for each direction. The policy MUST specify which is the preferred algorithm (e.g., the first algorithm listed in each category).",
      "ja": "o 暗号化、整合性、および圧縮アルゴリズム。方向ごとに個別に。ポリシーでは、どちらが優先アルゴリズムであるかを指定する必要があります（たとえば、各カテゴリにリストされている最初のアルゴリズム）。"
    },
    {
      "indent": 3,
      "text": "o Public key algorithms and key exchange method to be used for host authentication. The existence of trusted host keys for different public key algorithms also affects this choice.",
      "ja": "o ホスト認証に使用される公開鍵アルゴリズムと鍵交換方式。さまざまな公開鍵アルゴリズムの信頼できるホスト鍵の存在も、この選択に影響します。"
    },
    {
      "indent": 3,
      "text": "o The authentication methods that are to be required by the server for each user. The server's policy MAY require multiple authentication for some or all users. The required algorithms MAY depend on the location from where the user is trying to gain access.",
      "ja": "o サーバーが各ユーザーに要求する認証方法。サーバーのポリシーでは、一部またはすべてのユーザーに対して複数の認証が必要になる場合があります。必要なアルゴリズムは、ユーザーがアクセスを取得しようとしている場所に依存する場合があります。"
    },
    {
      "indent": 3,
      "text": "o The operations that the user is allowed to perform using the connection protocol. Some issues are related to security; for example, the policy SHOULD NOT allow the server to start sessions or run commands on the client machine, and MUST NOT allow connections to the authentication agent unless forwarding such connections has been requested. Other issues, such as which TCP/IP ports can be forwarded and by whom, are clearly issues of local policy. Many of these issues may involve traversing or bypassing firewalls, and are interrelated with the local security policy.",
      "ja": "o ユーザーが接続プロトコルを使用して実行できる操作。一部の問題はセキュリティに関連しています。たとえば、ポリシーはサーバーがクライアントマシンでセッションを開始したりコマンドを実行したりすることを許可してはならず（SHOULD NOT）、認証エージェントへの接続を許可してはなりません（そのような接続の転送が要求されていない場合）。どのTCP / IPポートを転送できるか、誰が転送できるかなどのその他の問題は、ローカルポリシーの問題です。これらの問題の多くは、ファイアウォールの通過またはバイパスを伴う可能性があり、ローカルセキュリティポリシーと相互に関連しています。"
    },
    {
      "indent": 0,
      "text": "4.4. Security Properties",
      "section_title": true,
      "ja": "4.4. セキュリティのプロパティ"
    },
    {
      "indent": 3,
      "text": "The primary goal of the SSH protocol is to improve security on the Internet. It attempts to do this in a way that is easy to deploy, even at the cost of absolute security.",
      "ja": "SSHプロトコルの主な目的は、インターネットのセキュリティを向上させることです。絶対的なセキュリティを犠牲にしても、展開が簡単な方法でこれを試みます。"
    },
    {
      "indent": 3,
      "text": "o All encryption, integrity, and public key algorithms used are well-known, well-established algorithms.",
      "ja": "o 使用されるすべての暗号化、整合性、および公開鍵アルゴリズムは、よく知られた確立されたアルゴリズムです。"
    },
    {
      "indent": 3,
      "text": "o All algorithms are used with cryptographically sound key sizes that are believed to provide protection against even the strongest cryptanalytic attacks for decades.",
      "ja": "o すべてのアルゴリズムは、何十年にもわたって最も強力な暗号解読攻撃からの保護を提供すると考えられている暗号的に健全な鍵サイズで使用されます。"
    },
    {
      "indent": 3,
      "text": "o All algorithms are negotiated, and in case some algorithm is broken, it is easy to switch to some other algorithm without modifying the base protocol.",
      "ja": "o すべてのアルゴリズムがネゴシエートされ、一部のアルゴリズムが壊れた場合でも、基本プロトコルを変更せずに他のアルゴリズムに簡単に切り替えることができます。"
    },
    {
      "indent": 3,
      "text": "Specific concessions were made to make widespread, fast deployment easier. The particular case where this comes up is verifying that the server host key really belongs to the desired host; the protocol allows the verification to be left out, but this is NOT RECOMMENDED. This is believed to significantly improve usability in the short term, until widespread Internet public key infrastructures emerge.",
      "ja": "広範で迅速な導入を容易にするために、特定の譲歩が行われました。これが発生する特定のケースは、サーバーホストキーが実際に目的のホストに属していることを確認することです。プロトコルでは検証を省略できますが、これは推奨されません。これにより、広範囲にわたるインターネット公開鍵インフラストラクチャが出現するまで、短期的には使いやすさが大幅に向上すると考えられています。"
    },
    {
      "indent": 0,
      "text": "4.5. Localization and Character Set Support",
      "section_title": true,
      "ja": "4.5. ローカリゼーションと文字セットのサポート"
    },
    {
      "indent": 3,
      "text": "For the most part, the SSH protocols do not directly pass text that would be displayed to the user. However, there are some places where such data might be passed. When applicable, the character set for the data MUST be explicitly specified. In most places, ISO-10646 UTF-8 encoding is used [RFC3629]. When applicable, a field is also provided for a language tag [RFC3066].",
      "ja": "ほとんどの場合、SSHプロトコルは、ユーザーに表示されるテキストを直接渡しません。ただし、そのようなデータが渡される可能性のある場所がいくつかあります。該当する場合、データの文字セットを明示的に指定する必要があります。ほとんどの場所で、ISO-10646 UTF-8エンコーディングが使用されます[RFC3629]。該当する場合、言語タグ[RFC3066]のフィールドも提供されます。"
    },
    {
      "indent": 3,
      "text": "One big issue is the character set of the interactive session. There is no clear solution, as different applications may display data in different formats. Different types of terminal emulation may also be employed in the client, and the character set to be used is effectively determined by the terminal emulation. Thus, no place is provided for directly specifying the character set or encoding for terminal session data. However, the terminal emulation type (e.g., \"vt100\") is transmitted to the remote site, and it implicitly specifies the character set and encoding. Applications typically use the terminal type to determine what character set they use, or the character set is determined using some external means. The terminal emulation may also allow configuring the default character set. In any case, the character set for the terminal session is considered primarily a client local issue.",
      "ja": "1つの大きな問題は、インタラクティブセッションの文字セットです。さまざまなアプリケーションがさまざまな形式でデータを表示する可能性があるため、明確な解決策はありません。異なるタイプの端末エミュレーションもクライアントで使用でき、使用する文字セットは端末エミュレーションによって効果的に決定されます。したがって、端末セッションデータの文字セットまたはエンコーディングを直接指定する場所はありません。ただし、ターミナルエミュレーションタイプ（「vt100」など）はリモートサイトに送信され、文字セットとエンコーディングを暗黙的に指定します。アプリケーションは通常、端末タイプを使用して、使用する文字セットを決定するか、文字セットは何らかの外部手段を使用して決定します。端末エミュレーションでは、デフォルトの文字セットを構成することもできます。いずれの場合も、ターミナルセッションの文字セットは、主にクライアントのローカルの問題と見なされます。"
    },
    {
      "indent": 3,
      "text": "Internal names used to identify algorithms or protocols are normally never displayed to users, and must be in US-ASCII.",
      "ja": "アルゴリズムまたはプロトコルを識別するために使用される内部名は、通常、ユーザーには表示されず、US-ASCIIである必要があります。"
    },
    {
      "indent": 3,
      "text": "The client and server user names are inherently constrained by what the server is prepared to accept. They might, however, occasionally be displayed in logs, reports, etc. They MUST be encoded using ISO 10646 UTF-8, but other encodings may be required in some cases. It is up to the server to decide how to map user names to accepted user names. Straight bit-wise, binary comparison is RECOMMENDED.",
      "ja": "クライアントとサーバーのユーザー名は、サーバーが受け入れる準備ができているものによって本質的に制約されます。ただし、ログ、レポートなどに表示される場合があります。ISO10646 UTF-8を使用してエンコードする必要がありますが、場合によっては他のエンコードが必要になることがあります。ユーザー名を受け入れられたユーザー名にマップする方法を決定するのはサーバーです。単純なビット単位のバイナリ比較が推奨されます。"
    },
    {
      "indent": 3,
      "text": "For localization purposes, the protocol attempts to minimize the number of textual messages transmitted. When present, such messages typically relate to errors, debugging information, or some externally configured data. For data that is normally displayed, it SHOULD be possible to fetch a localized message instead of the transmitted message by using a numerical code. The remaining messages SHOULD be configurable.",
      "ja": "ローカリゼーションの目的で、プロトコルは送信されるテキストメッセージの数を最小限に抑えようとします。通常、このようなメッセージは、エラー、デバッグ情報、または外部で構成されたデータに関連しています。通常表示されるデータの場合、数値コードを使用して、送信されたメッセージの代わりにローカライズされたメッセージをフェッチできるようにする必要があります。残りのメッセージは構成可能である必要があります。"
    },
    {
      "indent": 0,
      "text": "5. Data Type Representations Used in the SSH Protocols",
      "section_title": true,
      "ja": "5. SSHプロトコルで使用されるデータ型表現"
    },
    {
      "indent": 3,
      "text": "byte",
      "ja": "バイト"
    },
    {
      "indent": 6,
      "text": "A byte represents an arbitrary 8-bit value (octet). Fixed length data is sometimes represented as an array of bytes, written byte[n], where n is the number of bytes in the array.",
      "ja": "1バイトは、任意の8ビット値（オクテット）を表します。固定長データは、byte [n]と記述されたバイトの配列として表される場合があります。nは配列内のバイト数です。"
    },
    {
      "indent": 3,
      "text": "boolean",
      "ja": "ブール値"
    },
    {
      "indent": 6,
      "text": "A boolean value is stored as a single byte. The value 0 represents FALSE, and the value 1 represents TRUE. All non-zero values MUST be interpreted as TRUE; however, applications MUST NOT store values other than 0 and 1.",
      "ja": "ブール値は1バイトとして格納されます。値0はFALSEを表し、値1はTRUEを表します。ゼロ以外の値はすべてTRUEとして解釈する必要があります。ただし、アプリケーションは0と1以外の値を格納してはいけません。"
    },
    {
      "indent": 3,
      "text": "uint32",
      "ja": "スロベ"
    },
    {
      "indent": 6,
      "text": "Represents a 32-bit unsigned integer. Stored as four bytes in the order of decreasing significance (network byte order). For example: the value 699921578 (0x29b7f4aa) is stored as 29 b7 f4 aa.",
      "ja": "32ビットの符号なし整数を表します。重要度の降順（ネットワークバイト順）で4バイトとして格納されます。たとえば、値699921578（0x29b7f4aa）は29 b7 f4 aaとして格納されます。"
    },
    {
      "indent": 3,
      "text": "uint64",
      "ja": "uint64"
    },
    {
      "indent": 6,
      "text": "Represents a 64-bit unsigned integer. Stored as eight bytes in the order of decreasing significance (network byte order).",
      "ja": "64ビットの符号なし整数を表します。重要度の降順（ネットワークバイト順）で8バイトとして格納されます。"
    },
    {
      "indent": 3,
      "text": "string",
      "ja": "ストリング"
    },
    {
      "indent": 6,
      "text": "Arbitrary length binary string. Strings are allowed to contain arbitrary binary data, including null characters and 8-bit characters. They are stored as a uint32 containing its length (number of bytes that follow) and zero (= empty string) or more bytes that are the value of the string. Terminating null characters are not used.",
      "ja": "任意の長さのバイナリ文字列。文字列には、null文字や8ビット文字を含む任意のバイナリデータを含めることができます。それらは、その長さ（後続のバイト数）とゼロ（=空の文字列）以上の文字列の値であるバイトを含むuint32として格納されます。ヌル文字の終了は使用されません。"
    },
    {
      "indent": 6,
      "text": "Strings are also used to store text. In that case, US-ASCII is used for internal names, and ISO-10646 UTF-8 for text that might be displayed to the user. The terminating null character SHOULD NOT normally be stored in the string. For example: the US-ASCII string \"testing\" is represented as 00 00 00 07 t e s t i n g. The UTF-8 mapping does not alter the encoding of US-ASCII characters.",
      "ja": "文字列はテキストの保存にも使用されます。その場合、US-ASCIIが内部名に使用され、ISO-10646 UTF-8がユーザーに表示されるテキストに使用されます。終端のnull文字は通常、文字列に格納してはいけません（SHOULD NOT）。例：US-ASCII文字列「testing」は00 00 00 07 t e s t i n gとして表されます。 UTF-8マッピングは、US-ASCII文字のエンコーディングを変更しません。"
    },
    {
      "indent": 3,
      "text": "mpint",
      "ja": "mpint"
    },
    {
      "indent": 6,
      "text": "Represents multiple precision integers in two's complement format, stored as a string, 8 bits per byte, MSB first. Negative numbers have the value 1 as the most significant bit of the first byte of the data partition. If the most significant bit would be set for a positive number, the number MUST be preceded by a zero byte. Unnecessary leading bytes with the value 0 or 255 MUST NOT be included. The value zero MUST be stored as a string with zero bytes of data.",
      "ja": "多精度整数を2の補数形式で表し、1バイトあたり8ビット、MSBファーストの文字列として格納されます。負の数は、データパーティションの最初のバイトの最上位ビットとして値1を持ちます。最上位ビットが正の数に設定される場合は、数値の前にゼロバイトを付ける必要があります。値0または255の不要な先行バイトを含めてはなりません（MUST NOT）。値0は、0バイトのデータを持つ文字列として格納する必要があります。"
    },
    {
      "indent": 6,
      "text": "By convention, a number that is used in modular computations in Z_n SHOULD be represented in the range 0 <= x < n.",
      "ja": "慣例により、Z_nのモジュラー計算で使用される数値は、0 <= x <nの範囲で表す必要があります（SHOULD）。"
    },
    {
      "indent": 9,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 9,
      "text": "value (hex)        representation (hex)\n-----------        --------------------\n0                  00 00 00 00\n9a378f9b2e332a7    00 00 00 08 09 a3 78 f9 b2 e3 32 a7\n80                 00 00 00 02 00 80\n-1234              00 00 00 02 ed cc\n-deadbeef          00 00 00 05 ff 21 52 41 11",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "name-list",
      "ja": "名前リスト"
    },
    {
      "indent": 6,
      "text": "A string containing a comma-separated list of names. A name-list is represented as a uint32 containing its length (number of bytes that follow) followed by a comma-separated list of zero or more names. A name MUST have a non-zero length, and it MUST NOT contain a comma (\",\"). As this is a list of names, all of the elements contained are names and MUST be in US-ASCII. Context may impose additional restrictions on the names. For example, the names in a name-list may have to be a list of valid algorithm identifiers (see Section 6 below), or a list of [RFC3066] language tags. The order of the names in a name-list may or may not be significant. Again, this depends on the context in which the list is used. Terminating null characters MUST NOT be used, neither for the individual names, nor for the list as a whole.",
      "ja": "名前のコンマ区切りリストを含む文字列。名前リストは、その長さ（後続のバイト数）とそれに続く0個以上の名前のコンマ区切りリストを含むuint32として表されます。名前の長さはゼロ以外でなければならず、カンマ（ \"、\"）を含んではいけません。これは名前のリストであるため、含まれているすべての要素は名前であり、US-ASCIIである必要があります。コンテキストにより、名前に追加の制限が課される場合があります。たとえば、名前リストの名前は、有効なアルゴリズム識別子のリスト（下記のセクション6を参照）、または[RFC3066]言語タグのリストである必要がある場合があります。名前リスト内の名前の順序は、重要な場合とそうでない場合があります。繰り返しますが、これはリストが使用されるコンテキストに依存します。個々の名前やリスト全体ではなく、終端のnull文字を使用してはなりません。"
    },
    {
      "indent": 7,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 7,
      "text": "value                      representation (hex)\n-----                      --------------------\n(), the empty name-list    00 00 00 00\n(\"zlib\")                   00 00 00 04 7a 6c 69 62\n(\"zlib,none\")              00 00 00 09 7a 6c 69 62 2c 6e 6f 6e 65",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6. Algorithm and Method Naming",
      "section_title": true,
      "ja": "6. アルゴリズムとメソッドの命名"
    },
    {
      "indent": 3,
      "text": "The SSH protocols refer to particular hash, encryption, integrity, compression, and key exchange algorithms or methods by name. There are some standard algorithms and methods that all implementations MUST support. There are also algorithms and methods that are defined in the protocol specification, but are OPTIONAL. Furthermore, it is expected that some organizations will want to use their own algorithms or methods.",
      "ja": "SSHプロトコルは、特定のハッシュ、暗号化、整合性、圧縮、および鍵交換アルゴリズムまたはメソッドを名前で参照します。すべての実装がサポートしなければならない標準のアルゴリズムとメソッドがいくつかあります。プロトコル仕様で定義されているがオプションのアルゴリズムとメソッドもあります。さらに、一部の組織は独自のアルゴリズムまたはメソッドを使用することを望んでいます。"
    },
    {
      "indent": 3,
      "text": "In this protocol, all algorithm and method identifiers MUST be printable US-ASCII, non-empty strings no longer than 64 characters. Names MUST be case-sensitive.",
      "ja": "このプロトコルでは、すべてのアルゴリズムとメソッドの識別子は、印刷可能なUS-ASCIIであり、64文字以下の空でない文字列である必要があります。名前は大文字と小文字を区別する必要があります。"
    },
    {
      "indent": 3,
      "text": "There are two formats for algorithm and method names:",
      "ja": "アルゴリズム名とメソッド名には2つの形式があります。"
    },
    {
      "indent": 3,
      "text": "o Names that do not contain an at-sign (\"@\") are reserved to be assigned by IETF CONSENSUS. Examples include \"3des-cbc\", \"sha-1\", \"hmac-sha1\", and \"zlib\" (the doublequotes are not part of the name). Names of this format are only valid if they are first registered with the IANA. Registered names MUST NOT contain an at-sign (\"@\"), comma (\",\"), whitespace, control characters (ASCII codes 32 or less), or the ASCII code 127 (DEL). Names are case-sensitive, and MUST NOT be longer than 64 characters.",
      "ja": "o アットマーク（ \"@\"）を含まない名前は、IETF CONSENSUSによって割り当てられるように予約されています。例には、「3des-cbc」、「sha-1」、「hmac-sha1」、および「zlib」が含まれます（二重引用符は名前の一部ではありません）。この形式の名前は、IANAに最初に登録された場合にのみ有効です。登録名には、アットマーク（ \"@\"）、コンマ（ \"、\"）、空白、制御文字（ASCIIコード32以下）、またはASCIIコード127（DEL）を含めてはなりません（MUST NOT）。名前は大文字と小文字が区別され、64文字以下にする必要があります。"
    },
    {
      "indent": 3,
      "text": "o Anyone can define additional algorithms or methods by using names in the format name@domainname, e.g., \"ourcipher-cbc@example.com\". The format of the part preceding the at-sign is not specified; however, these names MUST be printable US-ASCII strings, and MUST NOT contain the comma character (\",\"), whitespace, control characters (ASCII codes 32 or less), or the ASCII code 127 (DEL). They MUST have only a single at-sign in them. The part following the at-sign MUST be a valid, fully qualified domain name [RFC1034] controlled by the person or organization defining the name. Names are case-sensitive, and MUST NOT be longer than 64 characters. It is up to each domain how it manages its local namespace. It should be noted that these names resemble STD 11 [RFC0822] email addresses. This is purely coincidental and has nothing to do with STD 11 [RFC0822].",
      "ja": "o 「ourcipher-cbc@example.com」のように、名前@ドメイン名の形式の名前を使用して、誰でも追加のアルゴリズムまたはメソッドを定義できます。アットマークの前の部分の形式は指定されていません。ただし、これらの名前は印刷可能なUS-ASCII文字列である必要があり、カンマ文字（ \"、\"）、空白、制御文字（ASCIIコード32以下）、またはASCIIコード127（DEL）を含めることはできません。彼らはそれらに単一のアットサインのみを持たなければなりません。アットマークに続く部分は、名前を定義する人または組織によって制御される有効な完全修飾ドメイン名[RFC1034]である必要があります。名前は大文字と小文字が区別され、64文字以下にする必要があります。ローカル名前空間をどのように管理するかは、各ドメイン次第です。これらの名前はSTD 11 [RFC0822]の電子メールアドレスに似ていることに注意してください。これはまったくの偶然であり、STD 11 [RFC0822]とは関係ありません。"
    },
    {
      "indent": 0,
      "text": "7. Message Numbers",
      "section_title": true,
      "ja": "7. メッセージ番号"
    },
    {
      "indent": 3,
      "text": "SSH packets have message numbers in the range 1 to 255. These numbers have been allocated as follows:",
      "ja": "SSHパケットには、1〜255の範囲のメッセージ番号があります。これらの番号は、次のように割り当てられています。"
    },
    {
      "indent": 3,
      "text": "Transport layer protocol:",
      "ja": "トランスポート層プロトコル："
    },
    {
      "indent": 6,
      "text": "1 to 19 Transport layer generic (e.g., disconnect, ignore, debug, etc.) 20 to 29 Algorithm negotiation 30 to 49 Key exchange method specific (numbers can be reused for different authentication methods)",
      "ja": "1から19トランスポート層の汎用（切断、無視、デバッグなど）20から29アルゴリズムのネゴシエーション30から49鍵交換方法固有（番号はさまざまな認証方法に再利用できます）"
    },
    {
      "indent": 3,
      "text": "User authentication protocol:",
      "ja": "ユーザー認証プロトコル："
    },
    {
      "indent": 6,
      "text": "50 to 59 User authentication generic 60 to 79 User authentication method specific (numbers can be reused for different authentication methods)",
      "ja": "50から59ユーザー認証汎用60から79ユーザー認証方法固有（数値は異なる認証方法に再利用できます）"
    },
    {
      "indent": 3,
      "text": "Connection protocol:",
      "ja": "接続プロトコル："
    },
    {
      "indent": 6,
      "text": "80 to 89 Connection protocol generic 90 to 127 Channel related messages",
      "ja": "80〜89接続プロトコルの一般的な90〜127チャネル関連のメッセージ"
    },
    {
      "indent": 3,
      "text": "Reserved for client protocols:",
      "ja": "クライアントプロトコル用に予約済み："
    },
    {
      "indent": 6,
      "text": "128 to 191 Reserved",
      "ja": "128〜191予約済み"
    },
    {
      "indent": 3,
      "text": "Local extensions:",
      "ja": "ローカル拡張："
    },
    {
      "indent": 6,
      "text": "192 to 255 Local extensions",
      "ja": "192〜255ローカル拡張"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document is part of a set. The instructions for the IANA for the SSH protocol, as defined in this document, [SSH-USERAUTH], [SSH-TRANS], and [SSH-CONNECT], are detailed in [SSH-NUMBERS]. The following is a brief summary for convenience, but note well that [SSH-NUMBERS] contains the actual instructions to the IANA, which may be superseded in the future.",
      "ja": "このドキュメントはセットの一部です。このドキュメントで定義されている、SSHプロトコルのIANAの手順[SSH-USERAUTH]、[SSH-TRANS]、および[SSH-CONNECT]については、[SSH-NUMBERS]で詳しく説明しています。以下は便宜上の簡単な要約ですが、[SSH-NUMBERS]にはIANAへの実際の指示が含まれていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Allocation of the following types of names in the SSH protocols is assigned by IETF consensus:",
      "ja": "SSHプロトコルでの次のタイプの名前の割り当ては、IETFコンセンサスによって割り当てられます。"
    },
    {
      "indent": 3,
      "text": "o Service Names * Authentication Methods * Connection Protocol Channel Names * Connection Protocol Global Request Names * Connection Protocol Channel Request Names",
      "ja": "o サービス名*認証方法*接続プロトコルのチャネル名*接続プロトコルのグローバル要求名*接続プロトコルのチャネル要求名"
    },
    {
      "indent": 3,
      "text": "o Key Exchange Method Names",
      "ja": "o 鍵交換メソッド名"
    },
    {
      "indent": 3,
      "text": "o Assigned Algorithm Names * Encryption Algorithm Names * MAC Algorithm Names * Public Key Algorithm Names * Compression Algorithm Names",
      "ja": "o 割り当てられたアルゴリズム名*暗号化アルゴリズム名* MACアルゴリズム名*公開鍵アルゴリズム名*圧縮アルゴリズム名"
    },
    {
      "indent": 3,
      "text": "These names MUST be printable US-ASCII strings, and MUST NOT contain the characters at-sign (\"@\"), comma (\",\"), whitespace, control characters (ASCII codes 32 or less), or the ASCII code 127 (DEL). Names are case-sensitive, and MUST NOT be longer than 64 characters.",
      "ja": "これらの名前は印刷可能なUS-ASCII文字列である必要があり、アットマーク（ \"@\"）、コンマ（ \"、\"）、空白、制御文字（ASCIIコード32以下）、またはASCIIコード127（ DEL）。名前は大文字と小文字が区別され、64文字以下にする必要があります。"
    },
    {
      "indent": 3,
      "text": "Names with the at-sign (\"@\") are locally defined extensions and are not controlled by the IANA.",
      "ja": "アットマーク（ \"@\"）が付いた名前はローカルで定義された拡張子であり、IANAによって制御されません。"
    },
    {
      "indent": 3,
      "text": "Each category of names listed above has a separate namespace. However, using the same name in multiple categories SHOULD be avoided to minimize confusion.",
      "ja": "上記の名前の各カテゴリには、個別の名前空間があります。ただし、混乱を最小限にするために、複数のカテゴリで同じ名前を使用することは避けてください。"
    },
    {
      "indent": 3,
      "text": "Message numbers (see Section 7) in the range of 0 to 191 are allocated via IETF CONSENSUS, as described in [RFC2434]. Message numbers in the 192 to 255 range (local extensions) are reserved for PRIVATE USE, also as described in [RFC2434].",
      "ja": "[RFC2434]で説明されているように、0〜191の範囲のメッセージ番号（セクション7を参照）は、IETF CONSENSUSを介して割り当てられます。 [RFC2434]でも説明されているように、192〜255の範囲（ローカル拡張）のメッセージ番号は、PRIVATE USE用に予約されています。"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "In order to make the entire body of Security Considerations more accessible, Security Considerations for the transport, authentication, and connection documents have been gathered here.",
      "ja": "セキュリティに関する考慮事項全体にアクセスしやすくするために、トランスポート、認証、および接続に関するセキュリティに関する考慮事項がここに集められています。"
    },
    {
      "indent": 3,
      "text": "The transport protocol [SSH-TRANS] provides a confidential channel over an insecure network. It performs server host authentication, key exchange, encryption, and integrity protection. It also derives a unique session id that may be used by higher-level protocols.",
      "ja": "トランスポートプロトコル[SSH-TRANS]は、安全でないネットワーク上で機密チャネルを提供します。サーバーホスト認証、キー交換、暗号化、整合性保護を実行します。また、上位レベルのプロトコルで使用できる一意のセッションIDも取得します。"
    },
    {
      "indent": 3,
      "text": "The authentication protocol [SSH-USERAUTH] provides a suite of mechanisms that can be used to authenticate the client user to the server. Individual mechanisms specified in the authentication protocol use the session id provided by the transport protocol and/or depend on the security and integrity guarantees of the transport protocol.",
      "ja": "認証プロトコル[SSH-USERAUTH]は、サーバーに対してクライアントユーザーを認証するために使用できる一連のメカニズムを提供します。認証プロトコルで指定された個々のメカニズムは、トランスポートプロトコルによって提供されるセッションIDを使用するか、トランスポートプロトコルのセキュリティと整合性の保証に依存します。"
    },
    {
      "indent": 3,
      "text": "The connection protocol [SSH-CONNECT] specifies a mechanism to multiplex multiple streams (channels) of data over the confidential and authenticated transport. It also specifies channels for accessing an interactive shell, for proxy-forwarding various external protocols over the secure transport (including arbitrary TCP/IP protocols), and for accessing secure subsystems on the server host.",
      "ja": "接続プロトコル[SSH-CONNECT]は、機密で認証されたトランスポートを介してデータの複数のストリーム（チャネル）を多重化するメカニズムを指定します。また、対話型シェルにアクセスしたり、安全なトランスポート（任意のTCP / IPプロトコルを含む）を介してさまざまな外部プロトコルをプロキシ転送したり、サーバーホスト上の安全なサブシステムにアクセスしたりするためのチャネルも指定します。"
    },
    {
      "indent": 0,
      "text": "9.1. Pseudo-Random Number Generation",
      "section_title": true,
      "ja": "9.1. 疑似乱数の生成"
    },
    {
      "indent": 3,
      "text": "This protocol binds each session key to the session by including random, session specific data in the hash used to produce session keys. Special care should be taken to ensure that all of the random numbers are of good quality. If the random data here (e.g., Diffie-Hellman (DH) parameters) are pseudo-random, then the pseudo-random number generator should be cryptographically secure (i.e., its next output not easily guessed even when knowing all previous outputs) and, furthermore, proper entropy needs to be added to the pseudo-random number generator. [RFC4086] offers suggestions for sources of random numbers and entropy. Implementers should note the importance of entropy and the well-meant, anecdotal warning about the difficulty in properly implementing pseudo-random number generating functions.",
      "ja": "このプロトコルは、セッションキーの生成に使用されるハッシュにランダムなセッション固有のデータを含めることにより、各セッションキーをセッションにバインドします。すべての乱数が高品質になるように、特別な注意を払う必要があります。ここのランダムデータ（Diffie-Hellman（DH）パラメーターなど）が疑似ランダムである場合、疑似乱数ジェネレーターは暗号的に安全でなければなりません（つまり、次の出力は以前のすべての出力を知っていても簡単に推測できません）。さらに、疑似乱数ジェネレータに適切なエントロピーを追加する必要があります。 [RFC4086]は、乱数とエントロピーのソースの提案を提供します。実装者は、エントロピーの重要性と、疑似乱数生成関数を適切に実装することの難しさについての意味のある逸話的な警告に注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "The amount of entropy available to a given client or server may sometimes be less than what is required. In this case, one must either resort to pseudo-random number generation regardless of insufficient entropy or refuse to run the protocol. The latter is preferable.",
      "ja": "特定のクライアントまたはサーバーで使用できるエントロピーの量は、必要な量よりも少ない場合があります。この場合、不十分なエントロピーに関係なく疑似乱数を生成するか、プロトコルの実行を拒否する必要があります。後者が好ましい。"
    },
    {
      "indent": 0,
      "text": "9.2. Control Character Filtering",
      "section_title": true,
      "ja": "9.2. 制御文字フィルタリング"
    },
    {
      "indent": 3,
      "text": "When displaying text to a user, such as error or debug messages, the client software SHOULD replace any control characters (except tab, carriage return, and newline) with safe sequences to avoid attacks by sending terminal control characters.",
      "ja": "エラーメッセージやデバッグメッセージなどのテキストをユーザーに表示する場合、クライアントソフトウェアは、制御文字（タブ、キャリッジリターン、改行を除く）を安全なシーケンスに置き換えて、端末制御文字を送信することによる攻撃を回避する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "9.3. Transport",
      "section_title": true,
      "ja": "9.3. 輸送"
    },
    {
      "indent": 0,
      "text": "9.3.1. Confidentiality",
      "section_title": true,
      "ja": "9.3.1. 守秘義務"
    },
    {
      "indent": 3,
      "text": "It is beyond the scope of this document and the Secure Shell Working Group to analyze or recommend specific ciphers other than the ones that have been established and accepted within the industry. At the time of this writing, commonly used ciphers include 3DES, ARCFOUR, twofish, serpent, and blowfish. AES has been published by The US Federal Information Processing Standards as [FIPS-197], and the cryptographic community has accepted AES as well. As always, implementers and users should check current literature to ensure that no recent vulnerabilities have been found in ciphers used within products. Implementers should also check to see which ciphers are considered to be relatively stronger than others and should recommend their use to users over relatively weaker ciphers. It would be considered good form for an implementation to politely and unobtrusively notify a user that a stronger cipher is available and should be used when a weaker one is actively chosen.",
      "ja": "業界内で確立され受け入れられている暗号以外の特定の暗号を分析または推奨することは、このドキュメントおよびSecure Shellワーキンググループの範囲を超えています。この記事の執筆時点で一般的に使用されている暗号には、3DES、ARCFOUR、twofish、serpent、blowfishがあります。 AESは米国連邦情報処理標準によって[FIPS-197]として公開されており、暗号化コミュニティもAESを受け入れています。いつものように、実装者とユーザーは最新の文献をチェックして、製品内で使用される暗号に最近の脆弱性が発見されていないことを確認する必要があります。実装者は、どの暗号が他よりも比較的強力であると見なされるかを確認し、比較的弱い暗号よりもユーザーに使用することを推奨する必要があります。より強力な暗号が利用可能であり、より弱い暗号がアクティブに選択されている場合に使用する必要があることを、実装に対して礼儀正しくかつ控えめに通知することは、実装にとって適切な形式と見なされます。"
    },
    {
      "indent": 3,
      "text": "The \"none\" cipher is provided for debugging and SHOULD NOT be used except for that purpose. Its cryptographic properties are sufficiently described in [RFC2410], which will show that its use does not meet the intent of this protocol.",
      "ja": "「なし」の暗号はデバッグ用に提供されており、その目的以外では使用しないでください。その暗号特性は[RFC2410]で十分に説明されています、それはその使用がこのプロトコルの意図を満たさないことを示します。"
    },
    {
      "indent": 3,
      "text": "The relative merits of these and other ciphers may also be found in current literature. Two references that may provide information on the subject are [SCHNEIER] and [KAUFMAN]. Both of these describe the CBC mode of operation of certain ciphers and the weakness of this scheme. Essentially, this mode is theoretically vulnerable to chosen cipher-text attacks because of the high predictability of the start of packet sequence. However, this attack is deemed difficult and not considered fully practicable, especially if relatively long block sizes are used.",
      "ja": "これらの暗号と他の暗号の相対的なメリットも、現在の文献に記載されています。この主題に関する情報を提供する可能性のある2つの参考文献は、[SCHNEIER]と[KAUFMAN]です。これらはどちらも、特定の暗号のCBC操作モードと、この方式の弱点を説明しています。本質的に、このモードは、パケットシーケンスの開始の予測可能性が高いため、選択された暗号文攻撃に対して理論的に脆弱です。ただし、特に比較的長いブロックサイズが使用されている場合、この攻撃は困難であり、完全に実用的であるとは見なされていません。"
    },
    {
      "indent": 3,
      "text": "Additionally, another CBC mode attack may be mitigated through the insertion of packets containing SSH_MSG_IGNORE. Without this technique, a specific attack may be successful. For this attack (commonly known as the Rogaway attack [ROGAWAY], [DAI], [BELLARE]) to work, the attacker would need to know the Initialization Vector (IV) of the next block that is going to be encrypted. In CBC mode that is the output of the encryption of the previous block. If the attacker does not have any way to see the packet yet (i.e., it is in the internal buffers of the SSH implementation or even in the kernel), then this attack will not work. If the last packet has been sent out to the network (i.e., the attacker has access to it), then he can use the attack.",
      "ja": "さらに、SSH_MSG_IGNOREを含むパケットを挿入することで、別のCBCモードの攻撃を軽減できます。この手法がなければ、特定の攻撃が成功する可能性があります。この攻撃（一般にRogaway攻撃[ROGAWAY]、[DAI]、[BELLARE]として知られています）が機能するためには、攻撃者は暗号化される次のブロックの初期化ベクトル（IV）を知っている必要があります。 CBCモードでは、前のブロックの暗号化の出力です。攻撃者がまだパケットを見る方法がない場合（つまり、SSH実装の内部バッファー内、またはカーネル内にある場合）、この攻撃は機能しません。最後のパケットがネットワークに送信された場合（つまり、攻撃者がそれにアクセスできる場合）、攻撃を使用できます。"
    },
    {
      "indent": 3,
      "text": "In the optimal case, an implementer would need to add an extra packet only if the packet has been sent out onto the network and there are no other packets waiting for transmission. Implementers may wish to check if there are any unsent packets awaiting transmission; unfortunately, it is not normally easy to obtain this information from the kernel or buffers. If there are no unsent packets, then a packet containing SSH_MSG_IGNORE SHOULD be sent. If a new packet is added to the stream every time the attacker knows the IV that is supposed to be used for the next packet, then the attacker will not be able to guess the correct IV, thus the attack will never be successful.",
      "ja": "最適なケースでは、実装者は、パケットがネットワークに送出され、他のパケットが送信を待機していない場合にのみ、追加のパケットを追加する必要があります。実装者は、送信を待っている未送信のパケットがあるかどうかを確認したい場合があります。残念ながら、カーネルやバッファからこの情報を取得することは通常簡単ではありません。未送信のパケットがない場合は、SSH_MSG_IGNOREを含むパケットを送信する必要があります（SHOULD）。攻撃者が次のパケットに使用されるはずのIVを認識するたびに新しいパケットがストリームに追加されると、攻撃者は正しいIVを推測できないため、攻撃は成功しません。"
    },
    {
      "indent": 3,
      "text": "As an example, consider the following case:",
      "ja": "例として、次のケースを考えます。"
    },
    {
      "indent": 6,
      "text": "Client                                                  Server\n------                                                  ------\nTCP(seq=x, len=500)             ---->\n contains Record 1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 26,
      "text": "[500 ms passes, no ACK]",
      "ja": "「５００ ｍｓ ぱっせｓ、 の あＣＫ」"
    },
    {
      "indent": 6,
      "text": "TCP(seq=x, len=1000)            ---->\n contains Records 1,2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 64,
      "text": "ACK",
      "ja": "アラス"
    },
    {
      "indent": 3,
      "text": "1. The Nagle algorithm + TCP retransmits mean that the two records get coalesced into a single TCP segment.",
      "ja": "1. Nagleアルゴリズム+ TCP再送信は、2つのレコードが単一のTCPセグメントに結合されることを意味します。"
    },
    {
      "indent": 3,
      "text": "2. Record 2 is not at the beginning of the TCP segment and never will be because it gets ACKed.",
      "ja": "2. レコード2はTCPセグメントの先頭ではなく、ACKされるため決してありません。"
    },
    {
      "indent": 3,
      "text": "3. Yet, the attack is possible because Record 1 has already been seen.",
      "ja": "3. しかし、レコード1はすでに確認されているため、攻撃は可能です。"
    },
    {
      "indent": 3,
      "text": "As this example indicates, it is unsafe to use the existence of unflushed data in the TCP buffers proper as a guide to whether an empty packet is needed, since when the second write() is performed the buffers will contain the un-ACKed Record 1.",
      "ja": "この例が示すように、2番目のwrite()が実行されるとバッファーにACKされていないレコード1が含まれるため、空のパケットが必要かどうかのガイドとして適切なTCPバッファー内のフラッシュされていないデータの存在を使用するのは安全ではありません。"
    },
    {
      "indent": 3,
      "text": "On the other hand, it is perfectly safe to have the following situation:",
      "ja": "一方、次のような状況が発生しても安全です。"
    },
    {
      "indent": 6,
      "text": "Client                                                  Server\n------                                                  ------\nTCP(seq=x, len=500)             ---->\n   contains SSH_MSG_IGNORE",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "TCP(seq=y, len=500)             ---->\n   contains Data",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Provided that the IV for the second SSH Record is fixed after the data for the Data packet is determined, then the following should be performed:",
      "ja": "データパケットのデータが決定された後、2番目のSSHレコードのIVが修正された場合、以下を実行する必要があります。"
    },
    {
      "indent": 9,
      "text": "read from user\nencrypt null packet\nencrypt data packet",
      "ja": "ユーザーからの読み取り\nnullパケットの暗号化\nデータパケットの暗号化"
    },
    {
      "indent": 0,
      "text": "9.3.2. Data Integrity",
      "section_title": true,
      "ja": "9.3.2. データの整合性"
    },
    {
      "indent": 3,
      "text": "This protocol does allow the Data Integrity mechanism to be disabled. Implementers SHOULD be wary of exposing this feature for any purpose other than debugging. Users and administrators SHOULD be explicitly warned anytime the \"none\" MAC is enabled.",
      "ja": "このプロトコルでは、データ整合性メカニズムを無効にすることができます。実装者は、デバッグ以外の目的でこの機能を公開することに注意する必要があります。ユーザーと管理者は、「なし」のMACが有効になっている場合は常に明示的に警告する必要があります。"
    },
    {
      "indent": 3,
      "text": "So long as the \"none\" MAC is not used, this protocol provides data integrity.",
      "ja": "「なし」のMACが使用されない限り、このプロトコルはデータの整合性を提供します。"
    },
    {
      "indent": 3,
      "text": "Because MACs use a 32-bit sequence number, they might start to leak information after 2**32 packets have been sent. However, following the rekeying recommendations should prevent this attack. The transport protocol [SSH-TRANS] recommends rekeying after one gigabyte of data, and the smallest possible packet is 16 bytes. Therefore, rekeying SHOULD happen after 2**28 packets at the very most.",
      "ja": "MACは32ビットのシーケンス番号を使用するため、2 ** 32パケットが送信された後、MACは情報をリークし始める可能性があります。ただし、キー再生成の推奨に従うことで、この攻撃を防ぐことができます。トランスポートプロトコル[SSH-TRANS]では、1ギガバイトのデータの後でキーの再生成を推奨しており、最小のパケットは16バイトです。したがって、鍵の再生成は、せいぜい2 ** 28パケット後に発生する必要があります。"
    },
    {
      "indent": 0,
      "text": "9.3.3. Replay",
      "section_title": true,
      "ja": "9.3.3. リプレイ"
    },
    {
      "indent": 3,
      "text": "The use of a MAC other than \"none\" provides integrity and authentication. In addition, the transport protocol provides a unique session identifier (bound in part to pseudo-random data that is part of the algorithm and key exchange process) that can be used by higher level protocols to bind data to a given session and prevent replay of data from prior sessions. For example, the authentication protocol ([SSH-USERAUTH]) uses this to prevent replay of signatures from previous sessions. Because public key authentication exchanges are cryptographically bound to the session (i.e., to the initial key exchange), they cannot be successfully replayed in other sessions. Note that the session id can be made public without harming the security of the protocol.",
      "ja": "「なし」以外のMACを使用すると、整合性と認証が提供されます。さらに、トランスポートプロトコルは、特定のセッションにデータをバインドし、データの再生を防ぐために上位レベルのプロトコルで使用できる一意のセッション識別子（アルゴリズムと鍵交換プロセスの一部である疑似ランダムデータに一部バインド）を提供します以前のセッションからのデータ。たとえば、認証プロトコル（[SSH-USERAUTH]）はこれを使用して、以前のセッションからの署名の再生を防ぎます。公開鍵認証交換はセッションに暗号化されて（つまり、最初の鍵交換に）バインドされているため、他のセッションでは正常に再生できません。セッションIDは、プロトコルのセキュリティを損なうことなく公開できることに注意してください。"
    },
    {
      "indent": 3,
      "text": "If two sessions have the same session id (hash of key exchanges), then packets from one can be replayed against the other. It must be stressed that the chances of such an occurrence are, needless to say, minimal when using modern cryptographic methods. This is all the more true when specifying larger hash function outputs and DH parameters.",
      "ja": "2つのセッションが同じセッションID（キー交換のハッシュ）を持っている場合、一方からのパケットを他方に対して再生できます。最新の暗号化方法を使用する場合、言うまでもなく、そのような発生の可能性は最小限であることを強調しなければなりません。これは、より大きなハッシュ関数の出力とDHパラメーターを指定する場合にはなおさら当てはまります。"
    },
    {
      "indent": 3,
      "text": "Replay detection using monotonically increasing sequence numbers as input to the MAC, or HMAC in some cases, is described in [RFC2085], [RFC2246], [RFC2743], [RFC1964], [RFC2025], and [RFC4120]. The underlying construct is discussed in [RFC2104]. Essentially, a different sequence number in each packet ensures that at least this one input to the MAC function will be unique and will provide a nonrecurring MAC output that is not predictable to an attacker. If the session stays active long enough, however, this sequence number will wrap. This event may provide an attacker an opportunity to replay a previously recorded packet with an identical sequence number but only if the peers have not rekeyed since the transmission of the first packet with that sequence number. If the peers have rekeyed, then the replay will be detected since the MAC check will fail. For this reason, it must be emphasized that peers MUST rekey before a wrap of the sequence numbers. Naturally, if an attacker does attempt to replay a captured packet before the peers have rekeyed, then the receiver of the duplicate packet will not be able to validate the MAC and it will be discarded. The reason that the MAC will fail is because the receiver will formulate a MAC based upon the packet contents, the shared secret, and the expected sequence number. Since the replayed packet will not be using that expected sequence number (the sequence number of the replayed packet will have already been passed by the receiver), the calculated MAC will not match the MAC received with the packet.",
      "ja": "MAC、または場合によってはHMACへの入力として単調に増加するシーケンス番号を使用するリプレイ検出は、[RFC2085]、[RFC2246]、[RFC2743]、[RFC1964]、[RFC2025]、および[RFC4120]で説明されています。基礎となる構成は[RFC2104]で説明されています。基本的に、各パケットのシーケンス番号が異なると、少なくともMAC関数へのこの1つの入力が一意になり、攻撃者が予測できない繰り返し発生しないMAC出力が提供されます。ただし、セッションが十分長くアクティブなままの場合、このシーケンス番号は折り返されます。このイベントは、同じシーケンス番号を持つ以前に記録されたパケットを再生する機会を攻撃者に提供する可能性がありますが、そのシーケンス番号を持つ最初のパケットの送信以降、ピアがキーを再生成していない場合のみです。ピアがキーを再生成した場合、MACチェックが失敗するため、リプレイが検出されます。このため、シーケンス番号をラップする前に、ピアがキーを再生成する必要があることを強調する必要があります。当然のことながら、ピアがキーを再生成する前に攻撃者がキャプチャしたパケットを再生しようとした場合、複製パケットの受信者はMACを検証できず、破棄されます。 MACが失敗する理由は、受信者がパケットの内容、共有シークレット、および予期されるシーケンス番号に基づいてMACを作成するためです。リプレイされたパケットはその予期されたシーケンス番号を使用しないため（リプレイされたパケットのシーケンス番号は受信側から既に渡されているため）、計算されたMACはパケットで受信したMACと一致しません。"
    },
    {
      "indent": 0,
      "text": "9.3.4. Man-in-the-middle",
      "section_title": true,
      "ja": "9.3.4. 真ん中の男"
    },
    {
      "indent": 3,
      "text": "This protocol makes no assumptions or provisions for an infrastructure or means for distributing the public keys of hosts. It is expected that this protocol will sometimes be used without first verifying the association between the server host key and the server host name. Such usage is vulnerable to man-in-the-middle attacks. This section describes this and encourages administrators and users to understand the importance of verifying this association before any session is initiated.",
      "ja": "このプロトコルは、ホストの公開鍵を配布するためのインフラストラクチャまたは手段を想定または提供していません。このプロトコルは、最初にサーバーホストキーとサーバーホスト名の関連付けを確認せずに使用されることが予想されます。このような使用法は、中間者攻撃に対して脆弱です。このセクションでは、これについて説明し、セッションを開始する前にこの関連付けを確認することの重要性を理解するよう管理者とユーザーに奨励します。"
    },
    {
      "indent": 3,
      "text": "There are three cases of man-in-the-middle attacks to consider. The first is where an attacker places a device between the client and the server before the session is initiated. In this case, the attack device is trying to mimic the legitimate server and will offer its public key to the client when the client initiates a session. If it were to offer the public key of the server, then it would not be able to decrypt or sign the transmissions between the legitimate server and the client unless it also had access to the private key of the host. The attack device will also, simultaneously to this, initiate a session to the legitimate server, masquerading itself as the client. If the public key of the server had been securely distributed to the client prior to that session initiation, the key offered to the client by the attack device will not match the key stored on the client. In that case, the user SHOULD be given a warning that the offered host key does not match the host key cached on the client. As described in Section 4.1, the user may be free to accept the new key and continue the session. It is RECOMMENDED that the warning provide sufficient information to the user of the client device so the user may make an informed decision. If the user chooses to continue the session with the stored public key of the server (not the public key offered at the start of the session), then the session-specific data between the attacker and server will be different between the client-to-attacker session and the attacker-to-server sessions due to the randomness discussed above. From this, the attacker will not be able to make this attack work since the attacker will not be able to correctly sign packets containing this session-specific data from the server, since he does not have the private key of that server.",
      "ja": "考慮すべき中間者攻撃の3つのケースがあります。 1つ目は、セッションが開始される前に、攻撃者がクライアントとサーバーの間にデバイスを置く場所です。この場合、攻撃デバイスは正当なサーバーを模倣しようとしており、クライアントがセッションを開始すると、公開鍵をクライアントに提供します。サーバーの公開鍵を提供する場合、ホストの秘密鍵にもアクセスできない限り、正当なサーバーとクライアント間の伝送を復号化または署名することはできません。攻撃デバイスは、これと同時に、正当なサーバーへのセッションを開始し、自身をクライアントに見せかけます。サーバーの公開鍵がセッションの開始前にクライアントに安全に配布されていた場合、攻撃デバイスによってクライアントに提供された鍵は、クライアントに保存されている鍵と一致しません。その場合、提供されたホストキーがクライアントにキャッシュされたホストキーと一致しないという警告がユーザーに表示される必要があります。セクション4.1で説明したように、ユーザーは自由に新しいキーを受け入れてセッションを続行できます。警告は、クライアントデバイスのユーザーに十分な情報を提供して、ユーザーが十分な情報に基づいて決定できるようにすることをお勧めします。ユーザーがサーバーの保存された公開鍵（セッションの開始時に提供された公開鍵ではない）でセッションを続行することを選択した場合、攻撃者とサーバー間のセッション固有のデータは、クライアントから上で説明したランダム性のため、攻撃者セッションと攻撃者からサーバーへのセッション。これにより、攻撃者はサーバーの秘密キーを持っていないため、サーバーからのこのセッション固有のデータを含むパケットに正しく署名できないため、攻撃者はこの攻撃を機能させることができません。"
    },
    {
      "indent": 3,
      "text": "The second case that should be considered is similar to the first case in that it also happens at the time of connection, but this case points out the need for the secure distribution of server public keys. If the server public keys are not securely distributed, then the client cannot know if it is talking to the intended server. An attacker may use social engineering techniques to pass off server keys to unsuspecting users and may then place a man-in-the-middle attack device between the legitimate server and the clients. If this is allowed to happen, then the clients will form client-to-attacker sessions, and the attacker will form attacker-to-server sessions and will be able to monitor and manipulate all of the traffic between the clients and the legitimate servers. Server administrators are encouraged to make host key fingerprints available for checking by some means whose security does not rely on the integrity of the actual host keys. Possible mechanisms are discussed in Section 4.1 and may also include secured Web pages, physical pieces of paper, etc. Implementers SHOULD provide recommendations on how best to do this with their implementation. Because the protocol is extensible, future extensions to the protocol may provide better mechanisms for dealing with the need to know the server's host key before connecting. For example, making the host key fingerprint available through a secure DNS lookup, or using Kerberos ([RFC4120]) over GSS-API ([RFC1964]) during key exchange to authenticate the server are possibilities.",
      "ja": "考慮すべき2番目のケースは、接続時にも発生するという点で1番目のケースと似ていますが、このケースはサーバー公開鍵の安全な配布の必要性を指摘しています。サーバーの公開鍵が安全に配布されていない場合、クライアントは目的のサーバーと通信しているかどうかを知ることができません。攻撃者はソーシャルエンジニアリング技術を使用して、疑いを持たないユーザーにサーバーキーを渡してから、正当なサーバーとクライアントの間にman-in-the-middle攻撃デバイスを配置する可能性があります。これが許可されている場合、クライアントはクライアントから攻撃者へのセッションを形成し、攻撃者は攻撃者からサーバーへのセッションを形成し、クライアントと正当なサーバー間のすべてのトラフィックを監視および操作できるようになります。サーバー管理者は、セキュリティが実際のホストキーの整合性に依存しないなんらかの方法で、ホストキーのフィンガープリントを確認できるようにすることをお勧めします。可能なメカニズムはセクション4.1で説明されており、セキュリティで保護されたWebページ、紙の物理的な断片なども含まれる場合があります。実装者は、実装でこれを行うための最善の方法に関する推奨事項を提供する必要があります。プロトコルは拡張可能であるため、プロトコルの将来の拡張により、接続前にサーバーのホストキーを知る必要性に対処するためのより良いメカニズムが提供される可能性があります。たとえば、安全なDNSルックアップを通じてホストキーフィンガープリントを利用可能にするか、サーバーを認証するためのキー交換中にGSS-API（[RFC1964]）経由でKerberos（[RFC4120]）を使用することが可能です。"
    },
    {
      "indent": 3,
      "text": "In the third man-in-the-middle case, attackers may attempt to manipulate packets in transit between peers after the session has been established. As described in Section 9.3.3, a successful attack of this nature is very improbable. As in Section 9.3.3, this reasoning does assume that the MAC is secure and that it is infeasible to construct inputs to a MAC algorithm to give a known output. This is discussed in much greater detail in Section 6 of [RFC2104]. If the MAC algorithm has a vulnerability or is weak enough, then the attacker may be able to specify certain inputs to yield a known MAC. With that, they may be able to alter the contents of a packet in transit. Alternatively, the attacker may be able to exploit the algorithm vulnerability or weakness to find the shared secret by reviewing the MACs from captured packets. In either of those cases, an attacker could construct a packet or packets that could be inserted into an SSH stream. To prevent this, implementers are encouraged to utilize commonly accepted MAC algorithms, and administrators are encouraged to watch current literature and discussions of cryptography to ensure that they are not using a MAC algorithm that has a recently found vulnerability or weakness.",
      "ja": "3番目のman-in-the-middleのケースでは、攻撃者は、セッションが確立された後、ピア間で転送中のパケットを操作しようと試みる可能性があります。セクション9.3.3で説明されているように、この種の攻撃が成功することはほとんどありません。セクション9.3.3のように、この推論はMACが安全であり、既知の出力を提供するためにMACアルゴリズムへの入力を構成することが実行不可能であることを前提としています。これについては、[RFC2104]のセクション6で詳しく説明しています。 MACアルゴリズムに脆弱性があるか、十分に弱い場合、攻撃者は特定の入力を指定して既知のMACを生成できる可能性があります。これにより、転送中のパケットの内容を変更できる可能性があります。または、攻撃者はアルゴリズムの脆弱性または脆弱性を利用して、キャプチャされたパケットからMACを確認することにより、共有秘密を見つけることができる場合があります。これらのいずれの場合でも、攻撃者はSSHストリームに挿入される可能性のあるパケットを構築する可能性があります。これを防ぐために、実装者は一般に受け入れられているMACアルゴリズムを利用することをお勧めします。管理者は、最新の脆弱性や弱点が見つかったMACアルゴリズムを使用していないことを確認するために、現在の文献と暗号化の議論を監視することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "In summary, the use of this protocol without a reliable association of the binding between a host and its host keys is inherently insecure and is NOT RECOMMENDED. However, it may be necessary in non-security-critical environments, and will still provide protection against passive attacks. Implementers of protocols and applications running on top of this protocol should keep this possibility in mind.",
      "ja": "要約すると、ホストとそのホストキー間のバインディングを確実に関連付けずにこのプロトコルを使用することは、本質的に安全ではなく、推奨されません。ただし、セキュリティが重要でない環境では必要になる場合があり、パッシブ攻撃に対する保護を提供します。プロトコルおよびこのプロトコル上で実行されるアプリケーションの実装者は、この可能性を覚えておく必要があります。"
    },
    {
      "indent": 0,
      "text": "9.3.5. Denial of Service",
      "section_title": true,
      "ja": "9.3.5. サービス拒否"
    },
    {
      "indent": 3,
      "text": "This protocol is designed to be used over a reliable transport. If transmission errors or message manipulation occur, the connection is closed. The connection SHOULD be re-established if this occurs. Denial of service attacks of this type (wire cutter) are almost impossible to avoid.",
      "ja": "このプロトコルは、信頼性の高いトランスポートで使用するように設計されています。送信エラーまたはメッセージ操作が発生した場合、接続は閉じられます。これが発生した場合、接続を再確立する必要があります（SHOULD）。このタイプのサービス拒否攻撃（ワイヤーカッター）を回避することはほとんど不可能です。"
    },
    {
      "indent": 3,
      "text": "In addition, this protocol is vulnerable to denial of service attacks because an attacker can force the server to go through the CPU and memory intensive tasks of connection setup and key exchange without authenticating. Implementers SHOULD provide features that make this more difficult, for example, only allowing connections from a subset of clients known to have valid users.",
      "ja": "さらに、このプロトコルはサービス拒否攻撃に対して脆弱です。これは、攻撃者が認証せずにサーバーにCPUとメモリを集中的に使用する接続設定とキー交換を通過させるためです。実装者は、これをより困難にする機能を提供する必要があります。たとえば、有効なユーザーがいることがわかっているクライアントのサブセットからの接続のみを許可します。"
    },
    {
      "indent": 0,
      "text": "9.3.6. Covert Channels",
      "section_title": true,
      "ja": "9.3.6. 隠れチャネル"
    },
    {
      "indent": 3,
      "text": "The protocol was not designed to eliminate covert channels. For example, the padding, SSH_MSG_IGNORE messages, and several other places in the protocol can be used to pass covert information, and the recipient has no reliable way of verifying whether such information is being sent.",
      "ja": "このプロトコルは、隠れチャネルを排除するようには設計されていません。たとえば、パディング、SSH_MSG_IGNOREメッセージ、およびプロトコルの他のいくつかの場所を使用して秘密情報を渡すことができ、受信者はそのような情報が送信されているかどうかを確認する確実な方法がありません。"
    },
    {
      "indent": 0,
      "text": "9.3.7. Forward Secrecy",
      "section_title": true,
      "ja": "9.3.7. 秘密の転送"
    },
    {
      "indent": 3,
      "text": "It should be noted that the Diffie-Hellman key exchanges may provide perfect forward secrecy (PFS). PFS is essentially defined as the cryptographic property of a key-establishment protocol in which the compromise of a session key or long-term private key after a given session does not cause the compromise of any earlier session [ANSI-T1.523-2001]. SSH sessions resulting from a key exchange using the diffie-hellman methods described in the section Diffie-Hellman Key Exchange of [SSH-TRANS] (including \"diffie-hellman-group1-sha1\" and \"diffie-hellman-group14-sha1\") are secure even if private keying/authentication material is later revealed, but not if the session keys are revealed. So, given this definition of PFS, SSH does have PFS. However, this property is not commuted to any of the applications or protocols using SSH as a transport. The transport layer of SSH provides confidentiality for password authentication and other methods that rely on secret data.",
      "ja": "Diffie-Hellman鍵交換は、Perfect Forward Secrecy（PFS）を提供する場合があることに注意してください。 PFSは基本的に、キー確立プロトコルの暗号化プロパティとして定義されています。このプロトコルでは、特定のセッション後のセッションキーまたは長期的な秘密キーの侵害が、以前のセッションの侵害を引き起こさない[ANSI-T1.523-2001] 。 [SSH-TRANS]のDiffie-Hellman鍵交換セクションで説明されているdiffie-hellman方式を使用した鍵交換から生じるSSHセッション（ \"diffie-hellman-group1-sha1\"と \"diffie-hellman-group14-sha1\"を含む）秘密鍵/認証情報が後で明らかになったとしても安全ですが、セッション鍵が明らかにされた場合はそうではありません。したがって、このPFSの定義を考えると、SSHにはPFSがあります。ただし、このプロパティは、SSHをトランスポートとして使用するアプリケーションやプロトコルには通用しません。 SSHのトランスポート層は、パスワード認証および秘密データに依存するその他の方法に機密性を提供します。"
    },
    {
      "indent": 3,
      "text": "Of course, if the DH private parameters for the client and server are revealed, then the session key is revealed, but these items can be thrown away after the key exchange completes. It's worth pointing out that these items should not be allowed to end up on swap space and that they should be erased from memory as soon as the key exchange completes.",
      "ja": "もちろん、クライアントとサーバーのDHプライベートパラメーターが公開されている場合、セッションキーは公開されますが、これらのアイテムはキー交換の完了後に破棄できます。これらのアイテムがスワップスペースに配置されてはならず、キー交換が完了するとすぐにメモリから消去されることに注意してください。"
    },
    {
      "indent": 0,
      "text": "9.3.8. Ordering of Key Exchange Methods",
      "section_title": true,
      "ja": "9.3.8. キー交換メソッドの順序"
    },
    {
      "indent": 3,
      "text": "As stated in the section on Algorithm Negotiation of [SSH-TRANS], each device will send a list of preferred methods for key exchange. The most-preferred method is the first in the list. It is RECOMMENDED that the algorithms be sorted by cryptographic strength, strongest first. Some additional guidance for this is given in [RFC3766].",
      "ja": "[SSH-TRANS]のアルゴリズムネゴシエーションのセクションで述べたように、各デバイスはキー交換の優先メソッドのリストを送信します。最も推奨される方法は、リストの最初です。アルゴリズムは、暗号強度で並べ替えることをお勧めします。これに関するいくつかの追加のガイダンスは[RFC3766]で与えられます。"
    },
    {
      "indent": 0,
      "text": "9.3.9. Traffic Analysis",
      "section_title": true,
      "ja": "9.3.9. トラフィック分析"
    },
    {
      "indent": 3,
      "text": "Passive monitoring of any protocol may give an attacker some information about the session, the user, or protocol specific information that they would otherwise not be able to garner. For example, it has been shown that traffic analysis of an SSH session can yield information about the length of the password - [Openwall] and [USENIX]. Implementers should use the SSH_MSG_IGNORE packet, along with the inclusion of random lengths of padding, to thwart attempts at traffic analysis. Other methods may also be found and implemented.",
      "ja": "プロトコルのパッシブモニタリングにより、攻撃者はセッション、ユーザー、またはプロトコル固有の情報を入手できます。たとえば、SSHセッションのトラフィック分析により、パスワードの長さに関する情報が得られることが示されています-[Openwall]および[USENIX]。実装者はSSH_MSG_IGNOREパケットを使用し、ランダムな長さのパディングを含めることで、トラフィック分析の試行を阻止する必要があります。他の方法を見つけて実装することもできます。"
    },
    {
      "indent": 0,
      "text": "9.4. Authentication Protocol",
      "section_title": true,
      "ja": "9.4. 認証プロトコル"
    },
    {
      "indent": 3,
      "text": "The purpose of this protocol is to perform client user authentication. It assumes that this runs over a secure transport layer protocol, which has already authenticated the server machine, established an encrypted communications channel, and computed a unique session identifier for this session.",
      "ja": "このプロトコルの目的は、クライアントのユーザー認証を実行することです。これは、サーバーマシンを既に認証し、暗号化された通信チャネルを確立し、このセッションの一意のセッション識別子を計算したセキュアなトランスポート層プロトコル上で実行されることを前提としています。"
    },
    {
      "indent": 3,
      "text": "Several authentication methods with different security characteristics are allowed. It is up to the server's local policy to decide which methods (or combinations of methods) it is willing to accept for each user. Authentication is no stronger than the weakest combination allowed.",
      "ja": "異なるセキュリティ特性を持ついくつかの認証方法が許可されています。各ユーザーに対してどのメソッド（またはメソッドの組み合わせ）を受け入れるかを決定するのは、サーバーのローカルポリシーです。認証は、許可されている最も弱い組み合わせよりも強力ではありません。"
    },
    {
      "indent": 3,
      "text": "The server may go into a sleep period after repeated unsuccessful authentication attempts to make key search more difficult for attackers. Care should be taken so that this doesn't become a self-denial of service vector.",
      "ja": "認証の試行が繰り返し失敗した後、サーバーがスリープ期間に入り、攻撃者がキー検索を困難にする可能性があります。これがサービス拒否の自己否定にならないように注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "9.4.1. Weak Transport",
      "section_title": true,
      "ja": "9.4.1. 弱い輸送"
    },
    {
      "indent": 3,
      "text": "If the transport layer does not provide confidentiality, authentication methods that rely on secret data SHOULD be disabled. If it does not provide strong integrity protection, requests to change authentication data (e.g., a password change) SHOULD be disabled to prevent an attacker from modifying the ciphertext without being noticed, or rendering the new authentication data unusable (denial of service).",
      "ja": "トランスポート層が機密性を提供しない場合は、秘密データに依存する認証方法を無効にする必要があります（SHOULD）。強力な整合性保護を提供しない場合は、認証データを変更するリクエスト（パスワードの変更など）を無効にして、攻撃者が気付かずに暗号文を変更したり、新しい認証データを使用不能（サービス拒否）にしたりしないようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "The assumption stated above, that the Authentication Protocol only runs over a secure transport that has previously authenticated the server, is very important to note. People deploying SSH are reminded of the consequences of man-in-the-middle attacks if the client does not have a very strong a priori association of the server with the host key of that server. Specifically, for the case of the Authentication Protocol, the client may form a session to a man-in- the-middle attack device and divulge user credentials such as their username and password. Even in the cases of authentication where no user credentials are divulged, an attacker may still gain information they shouldn't have by capturing key-strokes in much the same way that a honeypot works.",
      "ja": "認証プロトコルは以前にサーバーを認証した安全なトランスポート上でのみ実行されるという上記の仮定は、注意することが非常に重要です。 SSHを展開する人々は、クライアントがサーバーとそのサーバーのホストキーとのアプリオリな関連付けが非常に強力でない場合、中間者攻撃の結果を思い出します。具体的には、認証プロトコルの場合、クライアントは中間者攻撃デバイスへのセッションを形成し、ユーザー名やパスワードなどのユーザー資格情報を漏らします。ユーザーの資格情報が漏らされない認証の場合でも、ハニーポットが機能するのとほぼ同じ方法でキーストロークをキャプチャすることにより、攻撃者はまだ持っていないはずの情報を入手する可能性があります。"
    },
    {
      "indent": 0,
      "text": "9.4.2. Debug Messages",
      "section_title": true,
      "ja": "9.4.2. デバッグメッセージ"
    },
    {
      "indent": 3,
      "text": "Special care should be taken when designing debug messages. These messages may reveal surprising amounts of information about the host if not properly designed. Debug messages can be disabled (during user authentication phase) if high security is required. Administrators of host machines should make all attempts to compartmentalize all event notification messages and protect them from unwarranted observation. Developers should be aware of the sensitive nature of some of the normal event and debug messages, and may want to provide guidance to administrators on ways to keep this information away from unauthorized people. Developers should consider minimizing the amount of sensitive information obtainable by users during the authentication phase, in accordance with the local policies. For this reason, it is RECOMMENDED that debug messages be initially disabled at the time of deployment and require an active decision by an administrator to allow them to be enabled. It is also RECOMMENDED that a message expressing this concern be presented to the administrator of a system when the action is taken to enable debugging messages.",
      "ja": "デバッグメッセージを設計するときは、特別な注意が必要です。これらのメッセージは、適切に設計されていない場合、ホストに関する驚くべき量の情報を明らかにする可能性があります。高度なセキュリティが必要な場合は、デバッグメッセージを無効にできます（ユーザー認証フェーズ中）。ホストマシンの管理者は、すべてのイベント通知メッセージを区分して、不当な監視からメッセージを保護するためのあらゆる試みを行う必要があります。開発者は、一部の通常のイベントおよびデバッグメッセージの機密性を認識している必要があり、権限のない人からこの情報を遠ざける方法について管理者にガイダンスを提供したい場合があります。開発者は、ローカルポリシーに従って、認証フェーズ中にユーザーが取得できる機密情報の量を最小限に抑えることを検討する必要があります。このため、デバッグメッセージは展開時に最初は無効にして、有効にするために管理者が積極的に決定することをお勧めします。また、デバッグメッセージを有効にするアクションが実行されたときに、この懸念を表すメッセージをシステムの管理者に提示することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "9.4.3. Local Security Policy",
      "section_title": true,
      "ja": "9.4.3. ローカルセキュリティポリシー"
    },
    {
      "indent": 3,
      "text": "The implementer MUST ensure that the credentials provided validate the professed user and also MUST ensure that the local policy of the server permits the user the access requested. In particular, because of the flexible nature of the SSH connection protocol, it may not be possible to determine the local security policy, if any, that should apply at the time of authentication because the kind of service being requested is not clear at that instant. For example, local policy might allow a user to access files on the server, but not start an interactive shell. However, during the authentication protocol, it is not known whether the user will be accessing files, attempting to use an interactive shell, or even both. In any event, where local security policy for the server host exists, it MUST be applied and enforced correctly.",
      "ja": "実装者は、提供された資格情報が公言したユーザーを検証することを確認する必要があり、サーバーのローカルポリシーがユーザーに要求されたアクセスを許可することを確認する必要もあります。特に、SSH接続プロトコルには柔軟性があるため、要求されたサービスの種類がその時点で明確でないため、認証時に適用する必要があるローカルセキュリティポリシーを決定することができない場合があります。 。たとえば、ローカルポリシーでは、ユーザーはサーバー上のファイルにアクセスできますが、インタラクティブシェルを開始することはできません。ただし、認証プロトコルの間、ユーザーがファイルにアクセスするか、対話型シェルを使用しようとするか、あるいはその両方であるかは不明です。いずれにしても、サーバーホストのローカルセキュリティポリシーが存在する場合は、それを正しく適用および実施する必要があります。"
    },
    {
      "indent": 3,
      "text": "Implementers are encouraged to provide a default local policy and make its parameters known to administrators and users. At the discretion of the implementers, this default policy may be along the lines of anything-goes where there are no restrictions placed upon users, or it may be along the lines of excessively-restrictive, in which case, the administrators will have to actively make changes to the initial default parameters to meet their needs. Alternatively, it may be some attempt at providing something practical and immediately useful to the administrators of the system so they don't have to put in much effort to get SSH working. Whatever choice is made must be applied and enforced as required above.",
      "ja": "実装者は、デフォルトのローカルポリシーを提供し、そのパラメーターを管理者とユーザーに知らせることをお勧めします。実装者の裁量で、このデフォルトのポリシーは、ユーザーに制限が課されていない場合は何でも、または過度に制限されている場合があります。その場合、管理者は積極的に行う必要があります。必要に応じて、初期デフォルトパラメータを変更します。あるいは、システムの管理者に実用的ですぐに役立つ何かを提供しようとする試みである可能性があるため、SSHを動作させるために多くの労力を費やす必要はありません。上記の必要に応じて、選択した内容を適用して適用する必要があります。"
    },
    {
      "indent": 0,
      "text": "9.4.4 Public Key Authentication",
      "section_title": true,
      "ja": "9.4.4 公開鍵認証"
    },
    {
      "indent": 3,
      "text": "The use of public key authentication assumes that the client host has not been compromised. It also assumes that the private key of the server host has not been compromised.",
      "ja": "公開鍵認証の使用は、クライアントホストが危険にさらされていないことを前提としています。また、サーバーホストの秘密キーが危険にさらされていないことも前提としています。"
    },
    {
      "indent": 3,
      "text": "This risk can be mitigated by the use of passphrases on private keys; however, this is not an enforceable policy. The use of smartcards, or other technology to make passphrases an enforceable policy is suggested.",
      "ja": "このリスクは、秘密鍵にパスフレーズを使用することで軽減できます。ただし、これは強制可能なポリシーではありません。スマートカードまたはその他のテクノロジーを使用してパスフレーズを強制可能なポリシーにすることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The server could require both password and public key authentication; however, this requires the client to expose its password to the server (see the section on Password Authentication below.)",
      "ja": "サーバーは、パスワード認証と公開鍵認証の両方を要求できます。ただし、これにはクライアントがサーバーにパスワードを公開する必要があります（以下のパスワード認証のセクションを参照してください）。"
    },
    {
      "indent": 0,
      "text": "9.4.5. Password Authentication",
      "section_title": true,
      "ja": "9.4.5. パスワード認証"
    },
    {
      "indent": 3,
      "text": "The password mechanism, as specified in the authentication protocol, assumes that the server has not been compromised. If the server has been compromised, using password authentication will reveal a valid username/password combination to the attacker, which may lead to further compromises.",
      "ja": "認証プロトコルで指定されているパスワードメカニズムは、サーバーが危険にさらされていないことを前提としています。サーバーが危険にさらされている場合、パスワード認証を使用すると、有効なユーザー名とパスワードの組み合わせが攻撃者に明らかになるため、さらに危険にさらされる可能性があります。"
    },
    {
      "indent": 3,
      "text": "This vulnerability can be mitigated by using an alternative form of authentication. For example, public key authentication makes no assumptions about security on the server.",
      "ja": "この脆弱性は、代替の認証形式を使用することで軽減できます。たとえば、公開キー認証では、サーバーのセキュリティについて想定していません。"
    },
    {
      "indent": 0,
      "text": "9.4.6. Host-Based Authentication",
      "section_title": true,
      "ja": "9.4.6. ホストベースの認証"
    },
    {
      "indent": 3,
      "text": "Host-based authentication assumes that the client has not been compromised. There are no mitigating strategies, other than to use host-based authentication in combination with another authentication method.",
      "ja": "ホストベースの認証は、クライアントが危険にさらされていないことを前提としています。ホストベースの認証を別の認証方法と組み合わせて使用​​する以外に、緩和策はありません。"
    },
    {
      "indent": 0,
      "text": "9.5. Connection Protocol",
      "section_title": true,
      "ja": "9.5. 接続プロトコル"
    },
    {
      "indent": 0,
      "text": "9.5.1. End Point Security",
      "section_title": true,
      "ja": "9.5.1. エンドポイントのセキュリティ"
    },
    {
      "indent": 3,
      "text": "End point security is assumed by the connection protocol. If the server has been compromised, any terminal sessions, port forwarding, or systems accessed on the host are compromised. There are no mitigating factors for this.",
      "ja": "エンドポイントのセキュリティは、接続プロトコルによって想定されています。サーバーが危険にさらされている場合、ターミナルセッション、ポート転送、またはホスト上でアクセスされるシステムが危険にさらされます。これを緩和する要素はありません。"
    },
    {
      "indent": 3,
      "text": "If the client has been compromised, and the server fails to stop the attacker at the authentication protocol, all services exposed (either as subsystems or through forwarding) will be vulnerable to attack. Implementers SHOULD provide mechanisms for administrators to control which services are exposed to limit the vulnerability of other services. These controls might include controlling which machines and ports can be targeted in port-forwarding operations, which users are allowed to use interactive shell facilities, or which users are allowed to use exposed subsystems.",
      "ja": "クライアントが危険にさらされており、サーバーが認証プロトコルでの攻撃者の停止に失敗した場合、（サブシステムとして、または転送によって）公開されたすべてのサービスは、攻撃に対して脆弱になります。実装者は、他のサービスの脆弱性を制限するために公開されるサービスを管理者が制御するためのメカニズムを提供する必要があります（SHOULD）。これらの制御には、ポート転送操作の対象となるマシンやポート、対話型シェル機能の使用を許可するユーザー、公開されたサブシステムの使用を許可するユーザーの制御などがあります。"
    },
    {
      "indent": 0,
      "text": "9.5.2. Proxy Forwarding",
      "section_title": true,
      "ja": "9.5.2. プロキシ転送"
    },
    {
      "indent": 3,
      "text": "The SSH connection protocol allows for proxy forwarding of other protocols such as SMTP, POP3, and HTTP. This may be a concern for network administrators who wish to control the access of certain applications by users located outside of their physical location. Essentially, the forwarding of these protocols may violate site-specific security policies, as they may be undetectably tunneled through a firewall. Implementers SHOULD provide an administrative mechanism to control the proxy forwarding functionality so that site-specific security policies may be upheld.",
      "ja": "SSH接続プロトコルは、SMTP、POP3、HTTPなどの他のプロトコルのプロキシ転送を可能にします。これは、物理的な場所の外にいるユーザーによる特定のアプリケーションへのアクセスを制御することを望むネットワーク管理者にとっては問題になるかもしれません。本質的に、これらのプロトコルの転送は、ファイアウォールを介して検出不能にトンネリングされる可能性があるため、サイト固有のセキュリティポリシーに違反する可能性があります。実装者は、サイト固有のセキュリティポリシーを維持できるように、プロキシ転送機能を制御する管理メカニズムを提供する必要があります（SHOULD）。"
    },
    {
      "indent": 3,
      "text": "In addition, a reverse proxy forwarding functionality is available, which, again, can be used to bypass firewall controls.",
      "ja": "さらに、リバースプロキシ転送機能も利用できます。これも、ファイアウォール制御をバイパスするために使用できます。"
    },
    {
      "indent": 3,
      "text": "As indicated above, end-point security is assumed during proxy forwarding operations. Failure of end-point security will compromise all data passed over proxy forwarding.",
      "ja": "上記のように、プロキシ転送操作中はエンドポイントセキュリティが想定されます。エンドポイントセキュリティの失敗は、プロキシ転送を介して渡されるすべてのデータを危険にさらします。"
    },
    {
      "indent": 0,
      "text": "9.5.3. X11 Forwarding",
      "section_title": true,
      "ja": "9.5.3. X11転送"
    },
    {
      "indent": 3,
      "text": "Another form of proxy forwarding provided by the SSH connection protocol is the forwarding of the X11 protocol. If end-point security has been compromised, X11 forwarding may allow attacks against the X11 server. Users and administrators should, as a matter of course, use appropriate X11 security mechanisms to prevent unauthorized use of the X11 server. Implementers, administrators, and users who wish to further explore the security mechanisms of X11 are invited to read [SCHEIFLER] and analyze previously reported",
      "ja": "SSH接続プロトコルによって提供されるプロキシ転送の別の形式は、X11プロトコルの転送です。エンドポイントのセキュリティが侵害されている場合、X11転送はX11サーバーに対する攻撃を許可する可能性があります。ユーザーと管理者は、当然のことながら、適切なX11セキュリティメカニズムを使用して、X11サーバーの不正使用を防止する必要があります。 X11のセキュリティメカニズムをさらに探求したい実装者、管理者、およびユーザーは、[SCHEIFLER]を読んで、以前に報告されたものを分析することができます。"
    },
    {
      "indent": 3,
      "text": "problems with the interactions between SSH forwarding and X11 in CERT vulnerabilities VU#363181 and VU#118892 [CERT].",
      "ja": "CERT脆弱性VU＃363181およびVU＃118892 [CERT]でのSSH転送とX11間の相互作用に関する問題。"
    },
    {
      "indent": 3,
      "text": "X11 display forwarding with SSH, by itself, is not sufficient to correct well known problems with X11 security [VENEMA]. However, X11 display forwarding in SSH (or other secure protocols), combined with actual and pseudo-displays that accept connections only over local IPC mechanisms authorized by permissions or access control lists (ACLs), does correct many X11 security problems, as long as the \"none\" MAC is not used. It is RECOMMENDED that X11 display implementations default to allow the display to open only over local IPC. It is RECOMMENDED that SSH server implementations that support X11 forwarding default to allow the display to open only over local IPC. On single-user systems, it might be reasonable to default to allow the local display to open over TCP/IP.",
      "ja": "SSHを使用したX11ディスプレイ転送だけでは、X11セキュリティのよく知られた問題を修正するには不十分です[VENEMA]。ただし、SSH（または他の安全なプロトコル）でのX11ディスプレイ転送を、アクセス許可またはアクセス制御リスト（ACL）によって承認されたローカルIPCメカニズムを介してのみ接続を受け入れる実際のディスプレイと疑似ディスプレイと組み合わせると、多くのX11セキュリティ問題が修正されます「なし」のMACは使用されません。 X11ディスプレイ実装では、デフォルトでローカルIPC経由でのみディスプレイを開くことができるようにすることをお勧めします。ローカルIPC経由でのみディスプレイを開くことができるように、X11転送のデフォルトをサポートするSSHサーバー実装が推奨されます。シングルユーザーシステムでは、TCP / IPを介してローカルディスプレイを開くことができるようにデフォルト設定するのが妥当かもしれません。"
    },
    {
      "indent": 3,
      "text": "Implementers of the X11 forwarding protocol SHOULD implement the magic cookie access-checking spoofing mechanism, as described in [SSH-CONNECT], as an additional mechanism to prevent unauthorized use of the proxy.",
      "ja": "X11転送プロトコルの実装者は、[SSH-CONNECT]で説明されているように、プロキシの不正使用を防ぐための追加のメカニズムとして、マジッククッキーのアクセスチェックスプーフィングメカニズムを実装する必要があります（SHOULD）。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[SSH-TRANS] Ylonen, T. and C. Lonvick, Ed., \"The Secure Shell (SSH) Transport Layer Protocol\", RFC 4253, January 2006.",
      "ja": "[SSH-TRANS] Ylonen、T。およびC. Lonvick、編、「The Secure Shell（SSH）Transport Layer Protocol」、RFC 4253、2006年1月。"
    },
    {
      "indent": 3,
      "text": "[SSH-USERAUTH] Ylonen, T. and C. Lonvick, Ed., \"The Secure Shell (SSH) Authentication Protocol\", RFC 4252, January 2006.",
      "ja": "[SSH-USERAUTH] Ylonen、T。およびC. Lonvick、編、「The Secure Shell（SSH）Authentication Protocol」、RFC 4252、2006年1月。"
    },
    {
      "indent": 3,
      "text": "[SSH-CONNECT] Ylonen, T. and C. Lonvick, Ed., \"The Secure Shell (SSH) Connection Protocol\", RFC 4254, January 2006.",
      "ja": "[SSH-CONNECT] Ylonen、T。およびC. Lonvick、編、「The Secure Shell（SSH）Connection Protocol」、RFC 4254、2006年1月。"
    },
    {
      "indent": 3,
      "text": "[SSH-NUMBERS] Lehtinen, S. and C. Lonvick, Ed., \"The Secure Shell (SSH) Protocol Assigned Numbers\", RFC 4250, January 2006.",
      "ja": "[SSH-NUMBERS] Lehtinen、S。およびC. Lonvick、編、「Secure Shell（SSH）Protocol Assigned Numbers」、RFC 4250、2006年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2434] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 2434, October 1998.",
      "ja": "[RFC2434] Narten、T。およびH. Alvestrand、「RFCでIANAの考慮事項セクションを作成するためのガイドライン」、BCP 26、RFC 2434、1998年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC3066] Alvestrand, H., \"Tags for the Identification of Languages\", BCP 47, RFC 3066, January 2001.",
      "ja": "[RFC3066] Alvestrand、H。、「言語の識別のためのタグ」、BCP 47、RFC 3066、2001年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "ja": "[RFC3629] Yergeau、F。、「UTF-8、ISO 10646の変換フォーマット」、STD 63、RFC 3629、2003年11月。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[RFC0822] Crocker, D., \"Standard for the format of ARPA Internet text messages\", STD 11, RFC 822, August 1982.",
      "ja": "[RFC0822]クロッカーD。、「ARPAインターネットテキストメッセージのフォーマットの標準」、STD 11、RFC 822、1982年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC0854] Postel, J. and J. Reynolds, \"Telnet Protocol Specification\", STD 8, RFC 854, May 1983.",
      "ja": "[RFC0854] Postel、J。およびJ. Reynolds、「Telnet Protocol Specification」、STD 8、RFC 854、1983年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC1034] Mockapetris, P., \"Domain names - concepts and facilities\", STD 13, RFC 1034, November 1987.",
      "ja": "[RFC1034] Mockapetris、P。、「ドメイン名-概念と機能」、STD 13、RFC 1034、1987年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC1282] Kantor, B., \"BSD Rlogin\", RFC 1282, December 1991.",
      "ja": "[RFC1282] Office、B。、「BSD Rlogin」、RFC 1282、1991年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4120] Neuman, C., Yu, T., Hartman, S., and K. Raeburn, \"The Kerberos Network Authentication Service (V5)\", RFC 4120, July 2005.",
      "ja": "[RFC4120] Neuman、C.、Yu、T.、Hartman、S。、およびK. Raeburn、「The Kerberos Network Authentication Service（V5）」、RFC 4120、2005年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC1964] Linn, J., \"The Kerberos Version 5 GSS-API Mechanism\", RFC 1964, June 1996.",
      "ja": "[RFC1964] Linn、J。、「The Kerberos Version 5 GSS-API Mechanism」、RFC 1964、1996年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC2025] Adams, C., \"The Simple Public-Key GSS-API Mechanism (SPKM)\", RFC 2025, October 1996.",
      "ja": "[RFC2025] Adams、C。、「The Simple Public-Key GSS-API Mechanism（SPKM）」、RFC 2025、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2085] Oehler, M. and R. Glenn, \"HMAC-MD5 IP Authentication with Replay Prevention\", RFC 2085, February 1997.",
      "ja": "[RFC2085] Oehler、M。、およびR. Glenn、「HMAC-MD5 IP Authentication with Replay Prevention」、RFC 2085、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC2104] Krawczyk、H.、Bellare、M。、およびR. Canetti、「HMAC：Keyed-Hashing for Message Authentication」、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2246] Dierks, T. and C. Allen, \"The TLS Protocol Version 1.0\", RFC 2246, January 1999.",
      "ja": "[RFC2246] Dierks、T。およびC. Allen、「The TLS Protocol Version 1.0」、RFC 2246、1999年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC2410] Glenn, R. and S. Kent, \"The NULL Encryption Algorithm and Its Use With IPsec\", RFC 2410, November 1998.",
      "ja": "[RFC2410] Glenn、R。およびS. Kent、「NULL暗号化アルゴリズムとIPsecでのその使用」、RFC 2410、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2743] Linn, J., \"Generic Security Service Application Program Interface Version 2, Update 1\", RFC 2743, January 2000.",
      "ja": "[RFC2743] Linn、J。、「Generic Security Service Application Program Interface Version 2、Update 1」、RFC 2743、2000年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3766] Orman, H. and P. Hoffman, \"Determining Strengths For Public Keys Used For Exchanging Symmetric Keys\", BCP 86, RFC 3766, April 2004.",
      "ja": "[RFC3766]オーマン、H。、およびP.ホフマン、「対称鍵の交換に使用される公開鍵の強度の決定」、BCP 86、RFC 3766、2004年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake, D., 3rd, Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[RFC4086] Eastlake、D.、3rd、Schiller、J。、およびS. Crocker、「Randomness Requirements for Security」、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[FIPS-180-2] US National Institute of Standards and Technology, \"Secure Hash Standard (SHS)\", Federal Information Processing Standards Publication 180-2, August 2002.",
      "ja": "[FIPS-180-2]米国国立標準技術研究所、「Secure Hash Standard（SHS）」、連邦情報処理標準出版物180-2、2002年8月。"
    },
    {
      "indent": 3,
      "text": "[FIPS-186-2] US National Institute of Standards and Technology, \"Digital Signature Standard (DSS)\", Federal Information Processing Standards Publication 186- 2, January 2000.",
      "ja": "[FIPS-186-2]米国国立標準技術研究所、「デジタル署名標準（DSS）」、連邦情報処理標準出版物186-2、2000年1月。"
    },
    {
      "indent": 3,
      "text": "[FIPS-197] US National Institute of Standards and Technology, \"Advanced Encryption Standard (AES)\", Federal Information Processing Standards Publication 197, November 2001.",
      "ja": "[FIPS-197]米国国立標準技術研究所、「Advanced Encryption Standard（AES）」、連邦情報処理標準出版物197、2001年11月。"
    },
    {
      "indent": 3,
      "text": "[ANSI-T1.523-2001] American National Standards Institute, Inc., \"Telecom Glossary 2000\", ANSI T1.523-2001, February 2001.",
      "ja": "[ANSI-T1.523-2001] American National Standards Institute、Inc。、「Telecom Glossary 2000」、ANSI T1.523-2001、2001年2月。"
    },
    {
      "indent": 3,
      "text": "[SCHNEIER] Schneier, B., \"Applied Cryptography Second Edition: protocols algorithms and source in code in C\", John Wiley and Sons, New York, NY, 1996.",
      "ja": "[シュナイアー]シュナイアーB。、「Applied Cryptography Second Edition：protocol algorithm and source in code in C」、John Wiley and Sons、ニューヨーク、ニューヨーク、1996。"
    },
    {
      "indent": 3,
      "text": "[SCHEIFLER] Scheifler, R., \"X Window System : The Complete Reference to Xlib, X Protocol, Icccm, Xlfd, 3rd edition.\", Digital Press, ISBN 1555580882, February 1992.",
      "ja": "[SCHEIFLER] Scheifler、R。、「X Window System：The Complete Reference to Xlib、X Protocol、Icccm、Xlfd、3rd edition。」、Digital Press、ISBN 1555580882、1992年2月。"
    },
    {
      "indent": 3,
      "text": "[KAUFMAN] Kaufman, C., Perlman, R., and M. Speciner, \"Network Security: PRIVATE Communication in a PUBLIC World\", Prentice Hall Publisher, 1995.",
      "ja": "[KAUFMAN] Kaufman、C.、Perlman、R。、およびM. Speciner、「ネットワークセキュリティ：パブリックワールドでのプライベートコミュニケーション」、Prentice Hall Publisher、1995年。"
    },
    {
      "indent": 3,
      "text": "[CERT] CERT Coordination Center, The., \"http://www.cert.org/nav/index_red.html\".",
      "ja": "[CERT] CERT Coordination Center、The。、「http://www.cert.org/nav/index_red.html」。"
    },
    {
      "indent": 3,
      "text": "[VENEMA] Venema, W., \"Murphy's Law and Computer Security\", Proceedings of 6th USENIX Security Symposium, San Jose CA http://www.usenix.org/publications/library/ proceedings/sec96/venema.html, July 1996.",
      "ja": "[VENEMA]ヴェネマ、W、「マーフィーの法則とコンピュータセキュリティ」、第6回USENIXセキュリティシンポジウムの議事録、サンノゼカリフォルニアhttp://www.usenix.org/publications/library/procedings/sec96/venema.html、1996年7月。"
    },
    {
      "indent": 3,
      "text": "[ROGAWAY] Rogaway, P., \"Problems with Proposed IP Cryptography\", Unpublished paper http://www.cs.ucdavis.edu/~rogaway/ papers/draft-rogaway-ipsec-comments-00.txt, 1996.",
      "ja": "[ROGAWAY] Rogaway、P。、「Proposeds with Proposed IP Cryptography」、未公開の論文http://www.cs.ucdavis.edu/~rogaway/papers/draft-rogaway-ipsec-comments-00.txt、1996。"
    },
    {
      "indent": 3,
      "text": "[DAI] Dai, W., \"An attack against SSH2 protocol\", Email to the SECSH Working Group ietf-ssh@netbsd.org ftp:// ftp.ietf.org/ietf-mail-archive/secsh/2002- 02.mail, Feb 2002.",
      "ja": "[DAI] Dai、W。、「SSH2プロトコルに対する攻撃」、SECSHワーキンググループへのメールietf-ssh@netbsd.org ftp：// ftp.ietf.org/ietf-mail-archive/secsh/2002- 02 .mail、2002年2月。"
    },
    {
      "indent": 3,
      "text": "[BELLARE] Bellaire, M., Kohno, T., and C. Namprempre, \"Authenticated Encryption in SSH: Fixing the SSH Binary Packet Protocol\", Proceedings of the 9th ACM Conference on Computer and Communications Security, Sept 2002.",
      "ja": "[BELLARE] Bellaire、M.、Kohno、T。、およびC. Namprempre、「SSHでの認証済み暗号化：SSHバイナリパケットプロトコルの修正」、第9回コンピュータおよび通信セキュリティに関するACM会議の議事録、2002年9月。"
    },
    {
      "indent": 3,
      "text": "[Openwall] Solar Designer and D. Song, \"SSH Traffic Analysis Attacks\", Presentation given at HAL2001 and NordU2002 Conferences, Sept 2001.",
      "ja": "[Openwall]ソーラーデザイナーとD.ソング、「SSHトラフィック分析攻撃」、HAL2001およびNordU2002カンファレンスでのプレゼンテーション、2001年9月。"
    },
    {
      "indent": 3,
      "text": "[USENIX] Song, X.D., Wagner, D., and X. Tian, \"Timing Analysis of Keystrokes and SSH Timing Attacks\", Paper given at 10th USENIX Security Symposium, 2001.",
      "ja": "[USENIX] Song、X.D.、Wagner、D。、およびX. Tian、「キーストロークとSSHタイミング攻撃のタイミング分析」、2001年第10回USENIXセキュリティシンポジウムで発表された論文。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Tatu Ylonen SSH Communications Security Corp Valimotie 17 00380 Helsinki Finland",
      "ja": "Tatu Ylonen SSH Communications Security Corp Valimotie 17 00380 Helsinkiフィンランド"
    },
    {
      "indent": 3,
      "text": "EMail: ylo@ssh.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Chris Lonvick (editor) Cisco Systems, Inc. 12515 Research Blvd. Austin 78759 USA",
      "ja": "Chris Lonvick（編集者）Cisco Systems、Inc. 12515 Research Blvd.オースティン78759アメリカ"
    },
    {
      "indent": 3,
      "text": "EMail: clonvick@cisco.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Trademark Notice",
      "ja": "商標に関する通知"
    },
    {
      "indent": 3,
      "text": "\"ssh\" is a registered trademark in the United States and/or other countries.",
      "ja": "「ssh」は、米国およびその他の国における登録商標です。"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "Copyright（C）The Internet Society（2006）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "このドキュメントは、BCP 78に含まれる権利、ライセンス、および制限の対象であり、そこに記載されている場合を除き、著者はすべての権利を保持します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントとここに含まれる情報は、「現状のまま」で提供され、寄稿者、彼/彼女の代理人、または（もしあれば）組織、インターネットエンジニアリングおよびインターネットエンジニアリングタスクフォースは、すべての保証を明示的または明示的に提供します。ここに含まれる情報の使用により、商品性または特定の目的への適合性に関するいかなる権利または黙示の保証も侵害されないという保証を含みますが、これに限定されるものではありません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、このドキュメントに記載されているテクノロジーの実装または使用に関連すると主張される可能性がある知的財産権またはその他の権利の有効性または範囲、またはそのような権利に基づくライセンスが適用されるかどうかに関係なく、いかなる立場も取りません。利用できる;また、そのような権利を特定するために独立した取り組みを行ったことを表すものでもありません。 RFC文書の権利に関する手順に関する情報は、BCP 78およびBCP 79にあります。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局に対して行われたIPR開示のコピー、および利用可能になるライセンスの保証、または一般ライセンスを取得しようとした試み、またはこの仕様の実装者またはユーザーがそのような所有権を使用するための許可を取得した結果を取得できます。 http://www.ietf.org/iprのIETFオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、この規格を実装するために必要となる可能性のある技術をカバーする可能性のある著作権、特許、特許出願、またはその他の所有権に注意を向けるよう、関係者に呼びかけます。 IEETのietf-ipr@ietf.orgに情報を送信してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA).",
      "ja": "RFCエディター機能の資金は、IETF管理サポート活動（IASA）によって提供されます。"
    }
  ]
}
